# 3장. 웹 사이트 성능을 개선하는 기본적인 방법

## 3.1 HTTP 요청 수 줄이기

- 웹 페이지에 요청하는 콘텐츠 수가 많을수록 로딩 완료 시간이 길어진다.
- 웹 페이지를 단순하게 제작하는 방법이 HTTP 요청을 줄이는 가장 쉬운 방법이지만 웹 성능을 위해 콘텐츠를 줄이는 방법이 좋은 방법은 아니다.
- 페이지에 나타나는 콘텐츠는 동일하게 유지하며 HTTP 요청을 줄이는 방법을 찾아야 한다.

### 3.1.1 스크립트 파일 병합

- 기능 단위로 모듈화된 여러 파일들을 하나로 합쳐 HTTP 요청을 줄인다.
- 합쳐진 파일의 크기가 너무크다면 그 파일을 다운로드하는 시간이 오래걸리기 때문에 적절한 크기를 유지해야 한다.

### 3.1.2 인라인 이미지

- 이미지의 해시정보를 이용해 삽입하는 기법을 인라인 이미지라고 한다.
- 인라인 방식으로 웹 페이지 안에 이미지를 포함하는 경우 별도의 이미지 파일이 존재하지 않아 인터넷이나 브라우저에 캐시할 수 없으며, HTML이 캐시되어야 동시에 캐시할 수 있다.

### 3.1.3 CSS 스프라이트

- 여러개의 이미지를 하나의 파일로 결합해 필요한 위치가 있는 픽셀 좌표정보를 사용한다.

## 3.2 콘텐츠 파일 크기 줄이기

- 파일 자체의 크기가 크면 웹 성능에 부정적인 영향을 준다.

### 3.2.1 스크립트 파일 압축 전달

- 웹 서버가 지원하는 방식으로 스크립트 형태 콘텐츠를 압축해 클라이언트에게 더 작은 크기로 내려준다.
- 서로가 지원하는 다양한 압축 방식중 어떤 것을 사용할 지 골라야 한다.
- 클라이언트가 지원하지 않는 압축방식으로 내려주면 클라이언트는 이를 해체할수 없다.

- HTTP 프로토콜은 Accept-Encoding, Content-Encoding 헤더를 사용해 이러한 압축 방식의 정보를 교환한다.
- 요청 헤더는 Accept-Encoding, 응답 헤더는 Content-Encoding을 사용한다.

### 3.2.2 스크립트 파일 최소화

- HTML, 자바스크립트, CSS같이 코딩된 스크립트 파일에 포함된 주석, 공백, 개행문자 등 실제 로직에 아무런 영향을 주지않는 부분을 제거하여 파일의 크기를 줄인다.
- 개발자의 작업이 필요한 경우는 개발 서버와 운영 서버를 분리하여 작업한다.
- 가장 효과적인 방법은 스크립트 파일 최소화로 불필요한 부분을 제거해 파일을 가볍게 만든 후, gzip 등의 압축 방식으로 서버가 내려준 파일을 클라이언트가 압축 해제하는 두 방법을 모두 사용하는 것이다.

### 3.2.3 이미지 파일 압축

- 이미지 파일은 웹 사이트에서 가장 많은 용량을 차지하는 콘텐츠이다.
- 이미지 파일은 메타데이터를 저장하기 때문에 이러한 불필요한 부분을 제거하면 크기를 상당히 줄일 수 있다.

### 3.2.4 브라우저가 선호하는 이미지 파일 사용

- WebP와 JPEG XR이 대표적인 형식

#### WebP

- WebP는 손실 압축 방식을 사용하는 이미지 형식이다.
- 구글에서 개발하여 크롬 브라우저와 안드로이드에 적용하였다.
- 주로 사진 이미지의 압축 효과가 높고 화질 저하를 최소화하면서도 파일의 크기를 작게 만든다.
- JPEG보다 평균 50% 정도 파일의 크기가 작아딘다.

#### JPEG XR

- JPEG XR은 마이크로소프트가 JPEG 형식에 장점을 추가해 개발한 이미지 압축 형식이며 손실 압축과 비손실 압축 방식을 모두 지원한다.
- 마이크로소프트사의 웹 브라우저와 어도비사의 이미지 제작 툴이 이 형식을 사용한다.

### 3.2.5 큰 파일은 작게 나누어 전송

- 용량이 큰 동영상을 전부 다운로드 할 시 버퍼링이 발생한다.
- 이러한 경우 큰 파일의 일부분을 순서대로 다운로드하는 부분 요청 응답 방식을 사용할 수 있다.
- 이 방식은 동영상뿐만 아니라, 고화질의 큰 이미지, 매우 긴 문서 형태의 파일, 게임 패치 파일 등의 대용량 파일 전송에 사용된다.
- 크기를 가늠할 수 없는 콘텐츠를 전송할 때에도 유용하게 사용된다.
- 부분 요청 응답 방식은 웹 서버에 특정 부분 파일 전달을 지원하는 기능이 있을 때만 사용할 수 있다.

## 3.3 캐시 최적화하기

- 브라우저도 콘텐츠를 캐시하기 시작하였다.
- 빈번히 접속하는 웹 페이지에서는 자주 바뀌지 않는 이미지나 자바스크립트, CSS 파일 등을 인터넷 프록시 서버에도 캐시하지만 사용자의 브라우저도 해당 기기에 캐시한다.

### 3.3.1 인터넷 캐시 사용

- 프록시 서버는 인터넷상에서 자주 요청되는 콘텐츠를 캐시하며 속도와 인프라 보호차원에서 중요하다.
- 서버와 클라이언트 사이에서 통신을 대신하는 기능 자체를 프록시, 그 중계 기능을 수행하는 서버를 프록시 서버라고 한다.
- 프록시 서버는 클라이언트가 처음 요청한 콘텐츠를 원본 서버에 대신 요청하여 클라이언트에게 전달해주고 이를 스스로 저장한다.
- 이후 다른 클라이언트가 동일한 콘텐츠를 요청했을 때 원본 서버에 접속할 필요 없이 자체 저장한 콘텐츠를 제공한다.
- 프록시의 장점
  - 사용자 부근의 프록시 서버의 응답 속도가 원래 서버의 응답 속도보다 빠르다.
  - 원본 서버로 몰릴 수 있는 인터넷 트래픽을 프록시 서버로 분산해 원본 서버의 자원을 절약한다.

### 3.3.2 브라우저 캐시 사용

- 브라우저 캐시는 클라이언트 위치의 캐시이다.
- 특정 웹 사이트에 접속하여 받아온 웹 콘텐츠들 중 브라우저가 저장할 수 있는 콘텐츠들을 클라이언트 측에 저장해 인터넷상의 요청을 아예 하지 않겠다는 개념
- 캐시 정책이 결정되면 웹 서버는 Cache-Control 응답 헤더를 통해 설정 내용을 클라이언트에게 전달한다.
- 캐시가 생존하는 기간이라는 의미에서 TTL(Time-To Live)라고 부른다.

- max-age로 캐시할 시간 설정

```
Cache-Control: max-age=3600 //1시간 동안 캐시 사용
```

- 아무것도 캐싱 하지 않기

```
Cache-Control: no-store
```

- 브라우저의 캐시 여부를 사용하고 원본 서버의 콘텐츠 갱신 여부를 미리 조사해 변경이 없을 때만 캐시된 콘텐츠를 사용
- no-cache라고 해서 캐쉬를 사용하지 않겠다는 의미가 아님.

```
Cache-Control: no-cache
```

- 캐시 가능 주기를 확인하고 해당 시간 범위 내에서 캐시를 사용하고 싶을 때

```
Cache-Control: must-revalidate
```

- 캐시가 절대 불가능 함을 알려주는 헤더 값

```
Cache-Control:no-cache, no-store, must-revalidate
```

- 반대로 명확히 캐시할 수 있을 때는 public 지시자를 사용한다.
- public이면 공유 캐시(또는 중개 서버)에 저장해도 된다는 뜻이고 private면 브라우저 같은 특정 사용자 환경에만 저장하라는 뜻이다.

```
Cache-Control: public, max-age=3600
```

- 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age값이 있는 경우 이 헤더는 무시된다.

```
Expires: Thu, 26 Jul 2018 07:28:00 GMT
```

## 3.4 CDN 사용하기

- 인터넷상에서 생산,소비 되는 웹 콘텐츠를 사용자에게 빠르게 전달하기 위해 캐시서버 혹은 에지 서버라 불리는 대용량 인터넷 캐시 영역에 콘텐츠를 저장해 사용하는 네트워크 방식
- CDN은 주로 실제 인터넷 사용자가 가입한 ISP의 데이터 센터 내에 캐시 서버를 두고 이를 직접 사용자와 연결해 데이터를 전송한다.
