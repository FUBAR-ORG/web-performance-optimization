# 8장. 웹 프로토콜 최적화

## 8.1 HTTP의 발전

- HTTP/0.9는 GET 메소드만 존재
- 전달 받은 콘텐츠중 텍스트만 읽을 수 있었음
- HTTP/1.0부터는 HTML을 포함하는 HTTP 페이러도 외에도 헤더를 통해 클라이언트와 서버의 정보를 전달할 수 있었음.
- Content-Type 헤더를 이용해 이미지, 동영상 등 다양한 정보를 주고받을 수 있게 되었음.
- Content-Encoding 헤더를 이용해 클라이언트 서버간 압축 정보를 공유할 수 있었음

### 8.1.1 HTTP/1.1

- GET,POST 외에도 PUT과 DELETE를 이용해 파일을 업로드하거나 삭제할 방법이 생김
- Via 헤더를 사용해 중계 서버 정보를 공유
- Accect 헤더로 클라이언트가 어떤 콘텐츠를 지원하는지 서버에 미리 알려줄 수 있다.
- 하나의 TCP 연결을 재사용해 많은 콘텐츠를 전달할 수 있는 지속적 연결 기술이 추가
- 파이프라이닝은 브라우저가 웹 서버에 여러 개의 콘텐츠를 요청했을 때, 이전 요청에 대한 응답을 완전하게 받지 않더라도 지속적 연결로 확보한 하나의 TCP 연결 내에서 미리 다음 요청에 대한 처리를 시작하며 전체적인 전달시간을 줄이는 방식이다.
- 서버가 하나의 요청에 응답을 지연하면 나머지 모든 요청 역시 지연되는 문제가 생긴다.(HOL: Head-Of-Line blocking)

### 8.1.2 HTTP/2

- 구글이 시작한 SPDY 프로젝트.
- 텍스트 방식의 프로토콜 메시지를 버리고 이진 포맷을 사용해 프로토콜 자체를 경량화
- 멀티플렉싱, 스트림 우선순위 설정, 헤더 압축, 서버 푸시 같은 새로운 프토토콜 최적화 기능 추가
- HOL 문제 해결 못함

### 8.1.3 HTTP/3

- 새로운 인터넷 프로토콜인 QUIC을 사용하는 최상위 버전
- QUIC의 가장 큰 특징은 UDP를 사용
- 한 번 맺은 QUIC 연결을 최대한 재사용하는 구조이므로 연결을 만드는 과정에서 소모대는 시간이 대폭 줄어듬

## 8.2 HTTP/2의 최적화 기술

- HTTP/2의 가장 큰 목표는 콘텐츠를 주고받는 시간을 줄이고, 서버 응답이 느린 콘텐츠가 전달을 방해받지 않도록 하는 것
- 기존 문자열 방식의 프로토콜을 이진 프레임으로 바꿈
- HTTP 요청과 응답에 포함된 중복 헤더를 걸러내고, 전송할 값을 기존과 다르게 압축해 헤더의 크기를 최소화
- 요청하지 않은 콘텐츠도 미리 빠르게 전송해 RTT 최소화

### 8.2.1 HTTP/2의 이진 프레임

- HTTP/2의 3개 단위의 구조
  - 프레임: HTTP/2 통신상 제일 작은 정보 단위이며 헤더나 데이터 중 하나이다.
  - 메시지: HTTP/1.1 마찬가지로 요청 혹은 응답 단위이며 다수의 프레임으로 이루어져 있다.
  - 스트림: 클라이언트와 서버 사이 맺어진 연결을 통해 양방향으로 주고 받는 하나 혹은 복수의 메시지
- 여러개의 프레임이 모여 메시지가 되고 여러개의 메시지가 모여 스트림이 되는 구조
- 하나의 스트림이 다수의 요청, 응답을 포함하는 구조로 HTTP/1.1 버전보다 동시 요청 및 응답할 수 있는 오브젝트의 갯수가 많아짐
- 스트림의 유연한 구조 덕분에 요청 순서에 상관없이 만들어진 순서대로 클라이언트에게 전달할 수 있음
- 하나의 TCP 연결을 통해 요청과 응답이 비동기 방식으로 이루어지는 멀티플렉싱이 사용되어 HOL 문제를 자연스럽게 해결

### 8.2.2 멀티플렉싱

- 멀티플렉싱은 HTTP/1.1의 파이프라이닝 기능을 개선
- 파이프라이닝 기능은 선입 선출 방식을 사용했음
- 즉 먼저 요청된 콘텐츠가 완전히 전달되어 완료될 때까지 다음 콘텐츠는 대기상태로 있어야함
- HTTP/2의 스트림이 가진 유연한 구조 덕분에 서버에서 만들어진 응답 프레임들은 요청 순서에 상관없이 만들어진 순서대로 클라이언트에 전달될 수 있음
- 즉 TCP 연결상 요청과 응답이 비동기 방식으로 이루어지는 기술

### 8.2.3 헤더 압축

- 헤더는 압축없이 원래 크기 그대로 전달받는 문제점이 있었음
- 모든 웹 콘텐츠를 요청하고 받을 때마다 같은 정보 값들을 의미 없이 반복해서 주고받는 구조적인 문제도 있었음
- 클라이언트와 서버 사이의 가상 테이블을 만들어서 동일하고 중복되는 헤더 값들을 저장해 중복 전달을 제거했음
- 정적테이블: 미리 정의된 자주 사용되는 헤더 필드를 저장
- 동적테이블: 클라이언트와 서버가 통신하며 주고받는 값들을 업데이트
- 헤더 압축 알고리즘을 사용해 허프만 알고리즘 방식으로 헤더를 압축하여 좀 더 경량의 데이터를 주고받을 수 있게 되었음

### 8.2.4 서버 푸시

- 클라이언트 요청이 없어도 서버가 여러 응답을 알아서 보내는 서버 푸시 기능이 추가됨
- 클라이언트가 특정 콘텐츠를 요청하면 서버는 이후 추가될 요청을 미리 예상하고 요청없이도 응답
- 서버 푸시 대상은 웹 서버 관리자나 개발자가 미리 정할 수 있다.

## 8.3 HTTP/3의 최적화 기술

### 8.3.1 QUIC

- 구글 팀에서 공식 발표한 프로토콜
- QUID는 UDP를 채택해 TCP의 성능을 개선하려는 기술
- 전달 속도 향상과 클라이언트와 서버의 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는 것이 주요 특징
- 별도의 정보 교환 없이 바로 데이터를 보내는 기술이 Zero RTT

### 8.3.2 HTTP3/의 등장 배경

- HPACK, 서버 푸시 등은 어느 정도 성공을 거두었고, 프레임을 사용한 멀티플렉싱은 HOL 문제를 해결했지만, 여전히 TCP 스택을 사용했으므로 TCP 프로토콜 자체의 HOL을 완벽히 해결하진 못함
- TCP의 높은 신뢰성과 UDP의 빠른 성능을 토대로 마침내 QUIC 기반의 HTTP/3를 고안함

### 8.3.3 HTTP/3의 특징

- TCP/IP 기반 애플리케이션 레이어 프로토콜인 HTTP를 QUIC위로 위치 시킴.
- 이를 HTTP over QUIC를 줄여 HQ 라고 부름
- TCP의 HOL 문제만 개선한 것이 아니라 HTTP/2의 모든 기능을 계승해 UDP의 빠른 성능, QUIC의 효율성, TLS 1.3의 보안성까지 모든 장점을 가짐
