# 6장. 캐시 최적화

## 6.1 캐시

- 콘텐츠 요청에 빠르게 응답하기 위해 서버와 클라이언트 사이에서 응답 콘텐츠의 사본을 저장하는 공간을 캐시라 한다.
- 이 캐시를 유지하고 처리해주는 별도의 서버를 캐시 서버라고 한다.
- 기본적으로 브라우저가 사용하는 브라우저 캐시, 로컬 캐시, 서버 성능 향상을 위한 리버스 프록시 형태의 캐시 서버가 있다.
- 리버스 프록시 서버에 캐시 기능을 추가해 리버스 프록시 캐시 서버로 사용하기도 하는데 이를 웹 캐시라 한다.
- 캐시 서버는 원본 서버뿐만 아니라 프록시 서버, ISP 라우터 등 다양한 위치에 존재하며 네트워크 대역폭 및 비용 절감을 위해 사용된다.

## 6.2 웹 캐시 동작 원리

- 웹 캐시는 웹 서버와 웹 브라우저 중간에 존재
- 최초 원본 콘텐츠 요청을 최초 서버에 보내 응답 받은 후 그 복사본을 만들어 저장하고 사용자에게 응답한다.
- 이후 같은 요청이 오면 복사본을 전달한다.
- 모든 웹 콘텐츠를 캐시할 수 없다.
- 캐시서버는 HTTP/1.1 규격(RFC2616)을 기반으로 동작한다.

### 6.2.1 HTTP

- TCP Connection이 맺어지면 HTTP는 어떤 종류의 데이터는 전송 가능
- HTTP는 다음과 같은 특징이 있다.
  - 클라이언트 서버 모델로 동작
  - 비연결성이며 상태를 유지 하지 않는 프로토콜
  - 클라이언트와 서버간 HTTP 메시지를 주고받으며 통신
  - HTTP 메시지는 헤더와 바디부분으로 구분
  - 하위 Transport Layer 프로토콜로 TCP를 사용하는데 일반적으로 80포트 사용

### 6.2.2 HTTP의 캐시 제어 방식

- HTTP/1.1부터 명시적으로 캐시를 제어할 수 있는 헤더가 추가됨 이것이 Cache-Control 헤더
- 캐시를 제어하는 두 가지 목적
  - 원본 서버로의 요청 수를 최소화함: 사용자 요청에 대한 응답속도를 단축
  - 완전한 콘텐츠를 응답하지 않아도 됨

### 6.2.3 캐시 유효성 체크

- 캐시에 저장되어있는 응답의 age가 max-age를 넘었다면 신뢰할 수 없음.
- 캐시는 원본 서버에서 새 응답을 받아야함
- 반면 해당 콘텐츠에 아무런 변화가 없었다면 완전한 응답을 만들어 다시 보내는 것이 비효율 적임
- 이러한 비효율적 요청을 방지하고자 HTTP 표준은 `조건부 요청`이라는 메커니즘을 사용
- 이 메커니즘은 저장된 응답 TTL이 만료되었을 경우 TTL 주기 동안 콘텐츠에 변화가 있을 때에만 새 응답을 만들도록 요청

#### 시간 기반 조건부 요청

- 최종 변경 시간 중심으로 콘텐츠가 변경되었는지 확인하는 방법
- 어떤 시스템이든 저장된 객체가 변경되어 새로 저장되면 그 날짜와 시간을 메타데이터로 남김
- 응답을 만들어 보낼 때 `Last-Modified`라는 헤더에 최종 변경 날짜와 시간을 적어 보냄
- 캐시는 최초 요청에 대한 이 응답을 저장
- TTL 시간이 지난 이후 같은 요청이 오면 `"최종 변경 시간 이후 변경 사항이 있으면 전체 응답을 다시 주세요"`와 같은 요청을 함
- `If-Modified-Since`라는 헤더에 다음과 같이 `Last-Modified` 값을 복사해 원본 서버에 전송
- 이 날짜 이후 변경 사항이 있다면 `200`코드 없다면 `304` 코드가 담긴 응답 전송

#### 콘텐츠 기반의 조건부 요청

- 어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠 고윳값 중심으로 확인하는 방법
- 고윳값은 주로 해시값으로 추출
- 콘텐츠 내용이 약간이라도 수정되면 해시값이 변경되기 때문에 이 값을 비교해 변경 여부를 파악

- 원본 서버는 미리 정의된 대로 이 값을 만들어 `ETag` 헤더에 이 고윳값을 넣어 보냄

```
Cache-Control: public, max-age=31546000
ETag:"125124#ff213sfffasd#fadas"
```

- TTL 시간이 지난 이후 같은 요청이 오면 `"만약 이 콘텐츠와 일치하는 고윳값이 없다면 전체 응답을 다시주세요"`와 같은 요청을 함
- `If-none-match`라는 헤더에 다음과 같이 `ETag` 값을 복사해 원본 서버에 전송

### 6.2.4 캐시 콘텐츠 갱신

#### 퍼지

- 저장소를 완전히 지우는 방식으로 대부분의 캐시 서버가 캐시를 모두 지우는 명령어나 API를 제공한다.
- 또한 브라우저의 옵션 메뉴에서 로컬 캐시를 지울 수 있다.

#### 무효화

## 6.3 캐시 최적화 방안

- 캐시를 사용하는 주된 목적은 원본 서버로의 요청 수와 네트워크 대역폭 낭비를 줄여, 많은 트래픽을 처리해야 하는 원본 서버의 부담을 줄이는 것이다.
- 캐시 사용을 최대화할 수 있는 3가지의 기본원리
  - 최대한 많이 캐시
  - 최대한 오래 캐시
  - 최대한 가까이 캐시

### 6.3.1 캐시 가능한 콘텐츠 구분하기

- 어떤 콘텐츠를 개시할 수 있는지, 캐시하면 안되는지 바로 알아야함
- 캐시할 수 있는 리소스들을 최대한 찾아내 캐시를 통해 서비스 해야한다.
- 웹페이지의 구성은 WebPageTest를 통해 캐시할 수 있는 파일을 확인할 수 있다.
- 정적 콘텐츠란 URL을 호출할 때 마다 변함없이 같은 응답을 주는 콘텐츠로 이미지, CSS, 자바스크립트 등이 대표적인 정적 콘텐츠에 속한다.
- 동적 콘텐츠란 사용자가 요청할 때 마다 서버에 의해 다시 생성, 응답되는 콘텐츠
- 캐시하기 어려운 콘텐츠
  - 개인화된 콘텐츠
  - API 호출이나 Ajax 요청에 대한 콘텐츠
  - Beacon 전달 또는 쿠키 설정을 위한 호출

### 6.3.2 올바른 캐시 정책 결정하기

- 캐시할 수 있는 콘텐츠와 캐시할 수 없는 콘텐츠를 구분했으면 각 콘텐츠에 대한 캐시 정책을 정의.
- 캐시 정책을 세우는 것은 캐시할 콘텐츠의 성격을 파악하고 그룹화하는 것.
- 리소스들을 같은 타입끼리 그룹화하고 하위 그룹을 나누어 캐시 정책을 정함.

### 6.3.3 캐시 주기 결정하기

- 캐시 주기는 컨텐츠 타입별로 다르게 설정할 수 있습니다.
- 만약 링크 변경 없이 이미지 내용만 바꿔야 한다면 캐시 무효화 방식으로 해당 이미지만 캐시에 업데이트 한다.
- 모든 정적 파일에 대해 캐시 주기를 길게 설정하고 수동으로 캐시 주기를 관리하는 방법도 있다.

### 6.3.4 캐시에 적합한 디렉터리 구조 구성하기

- 캐시할 수 있는 컨텐츠들을 별도 폴더에 분류 관리한다.
  - 정적 콘텐츠를 `/static`이란 폴더에 배치해 캐시서버를 `/static*`처럼 간소하게 설정할 수 있다.
- 캐시 주기별로 나누어 구성한다.
  - 같은 콘텐츠 타입이라도 여러 가지 특성에 따라 캐시 주기가 다를 수 있다.
- 동일한 파일을 여러 곳에 분신시키지 않아야 한다.
  - 대부분의 캐시 서버는 URL을 키 값으로 하여 동작하므로 복제 생성되는 URL 수만큼 캐시에도 복사본이 생성되기 때문이다.

### 6.3.5 캐시 키 올바르게 사용하기

- 캐시 키란 캐시 서버가 원본의 복사본을 저장하고 빠르게 조회하기 위해 사용하는 키 값을 말한다.

#### 캐시 오염과 캐시 충돌

- 캐시에 복사본이 여러개 존재하는 것을 캐시 오염이라 한다.
- 캐시 충돌이란 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것을 의미한다.

#### 캐시 오염 제거

- 캐시 오염은 캐시 서버의 효율에 큰 영향을 줄 수 있다.
- URL에 붙은 특정 쿼리 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리 스트링을 무시하도록 설정한다.
- 쿼리 스트링 순서를 동일하게 정렬한다.
- Vary 헤더를 올바르게 사용해야 한다.
  - Vary 헤더: 서버의 응답이 상황에 따라 달라지는 것을 의미한다.

#### 캐시 충돌 방지

- 캐시 충돌은 동적 페이지를 캐시할 때 주로 발생한다.
- 기본적으로 동적 페이지에 대한 특별한 캐시설정은 하지않아야 한다.
- 일부 동적 페이지에 캐시를 사용하고자 한다면 Cache-Control: private으로 사용자 브라우저에만 캐시하여 페이지 로딩 시간을 단축할 수 있다.

### 6.3.6 CDN 사용하기

- 사용자에게 가깝게 캐시하는 방법
- 세계 여러 지역 데이터 센터들에 리버스 프록시 캐시서버를 두고 필요한 정적 콘텐츠를 저장할 수 있다.

## 6.4 동적 콘텐츠 캐시

### 6.4.1 동적 콘텐츠 캐시

- 동적 정보를 쿠키에 넣어 보낸다.
- Ajax 요청으로 관련 정보를 동적으로 받아온다.

- 보안에 주의해야 한다.
- 캐시 서버 용량에 유의한다.
- 캐시 키에 요청 쿠키, 헤더 또는 쿼리 스트링을 포함해 캐시할 수 있는 캐시 서버가 많지 않다.

### POST 응답 캐시

- 응답 내용이 보안 측면에서 공개되어도 안전한 내용이면 이 POST요청/응답도 캐시 할 수 있다.
- 캐시 키에 매개 변숫값들이 노출되지 않아야하므로 MD5 같은 해시 알고리즘을 이용해 타인이 쉽게 알 수 없도록 값을 암호화 한다.
- POST 요청/응답을 캐시하려면 다음과 같은 조건을 충족하여야함
  - 매개 변숫값에 항상 같은 응답이 오는 경우
  - 개인 정보가 포함되지 않은 경우
  - 요청 사이즈가 크지 않은 경우

## 6.5 고급 전략 캐시

### 6.5.1 Edge Side Inclue

- 일부 부분만 따로 떼어내어 수행시킨 후 캐시된 나머지 부분과 다시 조합할 수 있다면 로딩 성능이 개선될 수 있다.
- ESI란 웹 페이지 조각을 동적으로 조합, 전달할 수 있도록 문법과 용도를 정의한 XML 기반 마크업 언어다.
- ESI를 사용하면 웹 캐시에 저장된 index.html과 별도의 login.html을 조합해 완전한 html을 제공할 수 있다.
- 각 페이지를 독립 객체로 취급해 별도의 캐시 정책을 사용할 수 있다.
- 웹 캐시가 ESI 언어를 지원해야 사용할 수 있다.
- 캐시 서버는 HTML을 먼저 가져와 ESI 부분을 수행해 완벽한 HTML을 만들어 클라이언트에 전달한다.

### 6.5.2 HTML5 로컬 스토리지

- 웹 스토리지의 가장 중요한 역할은 쿠키를 대체한다.
- 사용자 정보는 쿠키를 통해 저장되고 매번 네트워크를 통해 전달되기 때문에 보안에 취약하다.

- 쿠키 대신 웹 스토리지를 사용하는 경우 데이터가 한 번 저장되면 얼마든지 불러 쓸 수 있어 보안상 더 안전하다.
- 네트워크 대역폭도 절감가능하다.
- key/value 페어로 저장되어 편리하게 사용가능하다.
- 렌더링에 중요한 CSS,js를 저장해놓으면 로딩 속도를 대폭 개선할 수 있다.
