# 6. 캐시 최적화

## 6.1 캐시
- 데이터를 매번 서버에서 가공해 제공하는 것은 오랜시간이 소요된다.
- 데이터 크키가 크거나 동시 요청 수가 많으면 제한된 리소스로 서버가 다운되거나 요청이 큐에 쌓여 오래 대기할 수 있다.
- 같은 요청에 응답하는 리소스가 똑같다면 캐시를 사용해 응답시간을 단축시킬 수 있다.

| 캐시 종류      | 위치        | 이점                                                          |
|------------|-----------|-------------------------------------------------------------|
| 브라우저 캐시    | 브라우저      | 다운로드한 리소스들을 재사용하여 로딩을 빠르게 함                                 |
| 프록시 캐시     | 브라우저와 ISP | 조직 내 사용자들이 접속하는 리소스들을 캐시하여 네트워크 연결과 대역폭 사용률을 감소시켜 로딩을 빠르게 함 |
| 트랜스패어런트 캐시 | ISP       | 캐시를 사용해 ISP 대역폭이 낭비되는 것을 방지                                 |
| 리버스 프록시 캐시 | ISP와 웹 서버 | 원본 서버로 향하는 트래픽 대역폭을 감소시키고, 사용자 응답을 개선                       |

## 6.2 웹 캐시 동작 원리
<img src="img/img_3.png" width="600px" height="400px">

- 원본 컨텐츠 요청을 서버를 통해 응답을 받은 후 복사본을 만들어 저장
- 이후 같은 컨텐츠에 대한 요청이 오면 캐시에서 복사본을 사용자에게 전달
- 원본 서버로의 트래픽을 줄이고 사용자 요청에 대한 반응속도를 빠르게 할 수 있다.

### 6.2.2 HTTP의 캐시 제어 방식

- HTTP/1.1부터 명시적으로 캐시를 제어할 수 있는 헤더(Cache-Control) 추가
- 캐시를 제어하는 목적
  - 원본 서버로의 요청 수를 최소화하여 네트워크 왕복 수를 줄여 결과적으로 사용자 요청에 대한 응답 속도 단축
  - 네트워크 대역폭과 리소스 낭비를 줄이고 비용을 효율화
  
#### Expire
- Expire 헤더를 사용해 원본 서버 컨텐츠의 유효기간을 지정
- 원본 서버는 Expire와 Date 헤더를 함께 보내며 Date 헤더는 요청에 대한 응답이 작성된 시점을 표시
- Expire에서 Date를 빼는 것으로 해당 응답의 캐시 유지 시간(Time To Live)을 결정할 수 있음
> Time To Live (TTL) = Expire_value - Date_value

#### Cache-Control: max-age
- Cache-Control: max-age라는 헤더로 캐시 유지 시간을 정의
- 캐시에서 특정 컨텐츠를 얼마나 오래 유지하고 있어야 하는지 명시적으로 설정
- Expire헤더는 만료일자를 지정하는 반면 Cache-Control: max-age는 유효기간을 지정

<img src="img/img_4.png" width="600px" height="400px">

1. 첫번째 요청에 대해 캐시된 응답이 없으므로 원본 서버에 그대로 요청을 전송
2. 원본 서버에서 응답을 생성하고 해당 객체의 유효기간을 HTTP 헤더에 명시
3. 캐시 서버는 요청에 대한 키와 함께 응답을 저장하고 만료일을 설정 후 응답을 전송
4. 이후 같은 요청이 만료일을 지나지 않았다면 캐시에 저장된 응답을 사용자에게 전송


#### Cache-Control: s-maxage
- CDN과 같은 공용 캐시 주기를 관리.
- 다수의 CDN 캐시를 동시에 사용하면 이들을 통합 관리하기 쉽지 않은데, s-maxage를 이용하면 사용 중인 모든 CDN의 캐시 주기를 일괄적으로 설정하거나 변경 가능.
- s-maxage는 표준으로 도입된지 얼마 되지 않았으므로 CDN 업체가 이 헤더를 지원하는지 확인해야 함.

#### ETag
- 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호.
- 원본 서버의 리소스가 시간이 지나 만료되었는지, 캐시된 리소스를 새로 갱신해야 하는지 여부를 명확히 판단 가능.
- ETag는 따옴표 안 임의 문자들의 조합으로 구성하며 어떤 조합이 될지는 전적으로 원본 서버가 결정.
>  ETag: "27dad37 1425fcc55e4d42a14879"

#### Cache-Control: public
- 응답이 모든 캐시 서버에 캐시될 수 있고, 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있음.

#### Cache-Control: private
- 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고 CDN 같은 범용 캐시 서버에서는 캐시 불가.
  - 범용 캐시 서버에서도 캐시할 수 있지만 사용자와 공유 불가.
- 일부 응답을 특정 사용자에게만 전달하는 데 목적이 있으므로 캐시 콘텐츠가 공유되면 안됨.
- 최종 사용자의 브라우저에서만이 응답을 자유롭게 캐시할 수 있지만, 응답에 담긴 개인 정보까지 보호되지는 않으니 주의해야 함.

#### Cache-Control: no-cache
- 요청과 응답 헤더에 모두 사용할 수 있지만 약간의 의미 차이가 있음.
- 요청 헤더
  - 브라우저는 원본 서버나 그 중간에 존재하는 캐시 서버들에게 캐시된 응답을 받지 않겠다는 메세지를 전달하는 것.
    - 캐시 서버들은 요청을 원본 서버에 그대로 전달해 최신의 응답을 받아 사용자에게 전달.
    - max-age=0을 사용하는 것과 비슷하게 동작하지만 미묘한 차이.
      - no-cache를 설정하면 캐시 서버는 항상 원본 서버로부터 최신 응답을 받아와야 함.
      - max-age=0은 캐시 서버가 원본 서버에서 전체 응답을 가져오기보다 이후 설명할 조건부 요청을 이용해 캐시된 콘텐츠에 변경이 있는 지를 먼저 검증.
        - 즉, 캐시된 응답이 여전히 유효하면 캐시에 있는 값을 반환.
- 응답 헤더
  - 원본 서버가 캐시 서버들에게 캐시된 응답을 보내기 전 원본 서버를 확인하도록 강제.
    - 캐시 서버는 최초 요청에 대해 원본 서버로부터 최신 응답을 받아 캐시에 저장한 뒤, 이후 같은 요청이 오면 캐시된 응답을 반환하기 전에 조건부 요청을 원본 서버에 보내 응답 메세지가 변경되지 않았는지 항상 확인.
    - 캐시 서버가 캐시하지 못하게 하는 것이 아니라 매 요청마다 캐시된 복사본을 원본 서버와 검증하라 강제하는 것. **max-age=0 설정과 동일하게 동작.**
  - 전체 응답이 아닌 특정 헤더 항목만 캐시하고 싶지 않다면 지시자 옆에 캐시하고 싶지 않은 헤더들을 나열하면 됨.
    - ex) `no-cache="Accept-Range"`: 캐시 서버는 응답을 캐시하되, `Accept-Range` 헤더는 캐시하지 않음.

#### Cache-Control: no-store
- 요청과 응답 헤더에 모두 사용할 수 있으며 쓰임새도 동일.
- 서버가 로컬 저장소에 메세지를 저장하지 않도록 지시.
- no-cache는 응답을 항상 최신 상태로 유지하도록 지시하지만 로컬 저장소에 저장하는 것을 막지 않음.
- no-store는 응답 메세지가 저장소에 저장되는 것 자체를 금지.
- 캐시 데이터의 예기치 않은 유출을 방지하려는 것.

### 6.2.3 캐시 유효성 체크
- 캐시된 컨텐츠가 만료되었을 때 원본 서버로부터 새 응답을 받아야 한다.
- 해당 컨텐츠에 아무런 변화가 없었다면 서버 자원과 네트워크 대역폭을 낭비하게 될 수 있다.
- TTL이 만료되었을 경우 항상 완전한 컨텐츠를 받아오는 대신 변화가 있을때만 응답을 만들도록 요청

### 시간 기반의 조건부 요청
<img src="img/img_5.png" width="600px" height="400px">

- 컨텐츠의 최종 변경 시간 중심으로 확인하는 방법
- 원본 서버가 응답을 보낼 때 Last-Modified 헤더에 최종 변경 날짜와 시간을 적어 보냄
> Cache-Control: public, max-age=31536000   
> Last-Modified: set, 26 Aug 2017 14:23:11 GMT
- TTL 시간이 지난 이후 같은 요청이 오면 IF-Modified-Since 헤더에 Last-Modified 값을 복사해 원본 서버에 전송
> If-Modified-Since: Set, 26 Aug 2017 14:23:11 GMT
- 이후 변경 사항이 있다면 원본 서버는 200코드와 함께 완전한 응답을, 없다면 304코드가 담긴 응답 헤더만을 돌려줌으로써 네트워크 자원 낭비를 막을 수 있다.


#### 컨텐츠 기반의 조건부 요청
<img src="img/img_6.png" width="600px" height="400px">

- 컨텐츠의 고유값 중심으로 확인하는 방법
- 주로 해시값을 추출해 컨텐츠 변경여부 파악
- 원본 서버는 ETag헤더에 고유값을 넣어 보냄
> Cache-Control: public, max-age=31536000   
> ETag: "150asdffasdjklassdjqwklasdf"
- 최초 요청에 대한 응답을 캐시에 저장하고 TTL 시간이 지난 후 같은 요청이 오면 If-None-Match 헤더에 ETag값을 복사하여 원본 서버에 전송
> If-None-Match: "150asdffasdjklassdjqwklasdf"


### 6.2.4 캐시 컨텐츠 갱신
 - 웹 사이트가 개편되었거나 컨텐츠를 급하게 변경했다면 캐시에 저장된 복사본들을 강제로 갱신해야 정상적인 서비스를 할 수 있음

#### 퍼지(purge)
- 저장소를 완전히 지우는 방식으로 대부분의 캐시 서버가 캐시를 모두 지우는 명령어나 API를 제공
- 브라우저에 옵션 메뉴에서 로컬 캐시를 삭제할 수 있음
- 한꺼번에 많은 컨텐츠를 퍼지하려면 한꺼번에 많은 요청일 몰릴 수 있기 때문에 서버에 충분한 자원이 있는지 확인하는 등 주의를 기울여야 한다.
  - 갑작스러운 퍼지는 피하고 리소스들을 캐시에 미리 저장해두거나 단계적으로 나누어 퍼지하는 방식을 취할 것

#### 무효화
- 캐시 저장소를 완전히 지우기보다 조건부 요청을 통해 변경이 있었던 리소스들만 갱신하는 방법
- 예와 같이 Cache-Control 헤더를 사용해 캐시 서버의 내용을 강제 무효화(invalidate)할 수 있다
> Cache-Control: max-age=0, must-revalidate
- 무효화 정책을 사용할 경우 퍼지와 동일하게 트래픽이 잠시 증가할 수 있음

## 6.3 캐시 최적화 방안
캐시 사용을 최대화할 수 있는 3가지 기본 원리
1. 최대한 많이 캐시하라
2. 최대한 오래 캐시하라
3. 최대한 가까이 캐시하라

### 6.3.1 캐시 가능한 컨텐츠 구분하기
<img src="img/img_7.png" width="600px" height="400px">

- 페이지 내 컨텐츠 종류 및 평균 크기

#### 컨텐츠 분류
- 정적 컨텐츠
  - URL을 호출할 때마다 같은 응답을 주는 컨텐츠
    - 이미지, CSS, 자바스크립트 등
- 동적 컨텐츠
  - 사용자가 요청할 때마다 서버에 의해 다시 생성, 응답되는 컨텐츠
    - 개인화된 컨텐츠: 사용자 정보에 따라 달라지는 컨텐츠로 원본 서버에서 가공되는 컨텐츠
    - API호출이나 Ajax 요청에 대한 컨텐츠: 사용자의 동적 정보를 원본 서버에 전달해 결과값을 받음. 인증이나 결제 등 빠르게 변하는 정보를 받을 때 사용
    - Beacon 전달 또는 쿠키 설정을 위한 호출: 사용자 정보를 수집하거나 쿠키설정을 위한 작은 이미지 호출 시 캐시에 저장된다면 원본 서버에 정보를 보낼 수 없음
    

### 6.3.2 올바를 캐시 정책 설정하기
<img src="img/img_8.png" width="600px" height="400px">

1. 캐시할 수 있는 컨텐츠인지 판단
2. 캐시할 수 있는 컨텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단
3. 캐시할 컨텐츠들의 성격을 판단
4. 캐시 주기를 설정하고 max-age를 추가

### 6.3.3 캐시 주기 결정하기
1. 컨텐츠 타입별로 다르게 설정할 수 있다
   - 이미지나 동영상 등 미디어 파일은 쉽게 변경되지 않음으로 캐시 주기를 1년 정도로 길게 설정하는 것을 권장
2. 링크 변경 없이 이미지 내용만 바꿔야 한다면 캐시 무효화(invalidation) 방식으로 해당 이미지만 캐시에 업데이트
   - 미디어 파일을 제외한 CSS, JS, 폰트 등 웹 리소스 파일들은 변경 빈도에 따라 다르게 설정하되 가능한 길게 설정
   - 변경 주기가 잦더라도 캐시하지 않는 것보다 짧게라도 캐시 주기를 정해 캐시하는 것이 성능에 유리
3. 모든 정적 파일에 캐시 주기를 길게 가져가고 수동으로 관리하는 방법도 있음
   - 수동으로 캐시 주기를 관리하는 방법
     1. 파일명 뒤에 해시값을 자동으로 붙여 파일명을 변경
     > package.b2cdd300.js   
     index.60c4c63d.js   
     lazy.dff9b213.js
     2. 파일 요청시에 쿼리 스트링으로 버전을 지정
     > core.min.js?201403121223   
     index.js?v=201403121223   
     lazy_loading.js?verseion=1.0

### 6.3.4 캐시에 적합한 디렉터리 구조 구성하기
1. 캐시할 수 있는 컨텐츠들을 별도의 폴더에 분류해 관리
> /static/image   
/static/css   
/static/js
2. 캐시 주기별로 나누어 구성
   - 모듈에 사용되는 스크립트는 자주 변경되지만, 라이브러리로 사용되는 스크립트는 쉽게 변경될 수 없음
> /static/js/lib   
/static/js/module/A   
/static/js/module/B
3. 동일한 파일을 여러 곳에 분산시키면 안됨
   - 대부분의 캐시 서버는 URL을 키 값으로 하여 동작하므로 URL수만큼 복사본이 생성
   - 캐시 서버 역시 제한된 메모리와 디스크 영역으로 동작하므로 필요없는 객체들로 리소스를 낭비하지 않아아함


### 6.3.5 캐시 키 올바르게 사용하기

#### 캐시 오염과 캐시 충돌
- 캐시 오염: 원본 서버에 하나의 파일만 존재하는데 캐시에 복사본이 여러개 존재하는 것
- 캐시 충돌: 요청 URL이 하나인데 브라우저 환경에 따라 응답이 달라지는 경우 최초 요청한 브라우저의 응답만 캐시되는 것

<img src="img/img_9.png" width="600px" height="400px">

#### 캐시 오염 제거
1. URL에 붙은 쿼리값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리를 무시하도록 설정
2. 쿼리 스트링의 순서를 동일하게 정렬
3. Vary 헤더를 바르게 사용
   - ex) 브라우저 환경에 따라 컨텐츠가 달라지는 경우 Vary헤더는 이를 캐시에 알려 다른 컨텐츠를 캐시하도록 한다.

#### 캐시 충돌 방지
- 로그인 전과 후에 개인화되어 사용자마다 다르게 보여야 하지만 로그인 전 화면을 캐시할 경우 같은 화면을 보게될 수 있음.
- 동적 페이지에는 캐시를 적용하지 않아야 하며, 일부 페이지에 캐시를 사용하고자 한다면 Cache-Control: private로 로딩시간을 단축시킬 수 있음

### 6.3.6 CDN 사용하기
- 사용자에게 가깝게 캐시하기 위해 CDN을 사용
- 글로벌 서비스에 경우 더욱 유용하게 사용할 수 있음


## 6.4 동적 컨텐츠 캐시
<img src="img/img_10.png" width="600px" height="400px">

### 6.4.1 동적 컨텐츠 캐시
<img src="img/img_11.png" width="600px" height="400px">

### 6.4.2 POST 응답 캐시
<img src="img/img_12.png" width="600px" height="400px">

- POST 요청/응답을 캐시하기 위한 조건
  - 매개 변수에 항상 같은 응답이 오는 경우
  - 개인 정보가 포함되지 않은 경우
  - 요청 사이즈가 크지 않은 경우 // 캐시 키는 하나의 스트링으로 구성되기 때문에 길이 제한이 있을 수 있음


## 6.5 고급 캐시 전략

### 6.5.1 Edge Side Include

### 6.5.2 HTML5 로컬 스토리지
- HTML5는 다양한 기능을 API를 통해 사용해 웹 페이지가 애플리케이션으로 구동될 수 있음
- HTML5 주요 기능
  - Semantic Tag: DIV를 통해 부여했던 Semantic을 표준 Tag로 정의해 사용해 가독성 및 사용자 접근성을 향상
  - Web Storage: API를 통해 세션, 로컬 스토리지, IndexedDb를 사용할 수 있고 오프라인 상태에서 웹페이지를 로딩할 수 있다
  - Multimedia: 플러그인 없이 오디오와 비디오를 재생할 수 있다
  - Graphics: 그래픽을 위한 툴박스가 SVG, Canvas, WebGL, CSS3 3D 등으로 확대되어 플러그인 없이 화려한 그래픽을 표현할 수 있다
  - Device Access: 기기의 마이크로폰, 카메라, 연락처, 이벤트 등에 네이티브 앱처럼 접근할 수 있다
  - Performance: Web Worker를 도입해 백그라운드 프로세싱 기능과 멀티스레드를 사용해 속도를 향상시켰다
  - Connectivity: Web Socket을 사용해 클라이언트와 서버 간 TCP 통신을 할 수 있다. 실시간 메시징, 푸시 알림 등 양방향 통신을 구현할 수 있다.
  - CSS3: CSS3를 지원하여 유연하고, 풍성한 화면을 더욱 쉽게 구현할 수 있다

- 쿠키의 문제점
  - 사용자 정보는 쿠키를 통해 저장되고 네트워크를 통해 전달되어 보안에 취약
  - 도메인당 4KB 이내로 만들어져야 하며 50개를 초과할 수 없는 제약이 있음
  - 별도 제한이 없다면 같은 도메인의 모든 요청에 쿠키가 추가되어 네트워크 대역폭을 낭비

- HTML5 웹 스토리지
    - HTML5 웹 스토리지의 중요한 역할은 쿠키를 대체하는 것
    - 최소 5MB 크기의 용량 제한으로 더 많은 데이터를 안전하게 저장할 수 있음
    - 종류
        - 세션 스토리지: 세션이 살아 있는 동안에만 저장
        - 로컬 스토리지: 영원히 저장
        - IndexedDB: 오브젝트 스토어로써 더 광법위한 데이터를 저장할 때 사용

- 사용자 정보뿐만 아니라 웹 사이트의 중요한 리소스를 저장하는 데도 사용할 수 있다
  - CSS, JS를 저장해놓으면 재방문시 로딩 속도를 대폭 개선할 수 있다
  - 폰트파일 역시 로컬 스토리지에 저장해 사이트 로딩 지연을 방지할 수 있다
    - API를 통해 리소스가 스토리지에 있는지 확인하고 없는 경우 동적으로 로딩시켜 리소스를 다운로드한다

