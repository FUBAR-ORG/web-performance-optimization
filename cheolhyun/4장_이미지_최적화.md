# 이미지 최적화

## 이미지의 중요성

- 직관을 중요시함에 따라 고품질 이미지를 사용해가며 이미지의 중요성은 날로 커져 감.
- 초창기와는 달리 초고속 인터넷 시대인 지금, 이미지의 크기는 점점 더 커지는 추세.
- 고해상도 디스플레이의 발전 또한 영향을 줌.

#### 화소 밀도

- 물리 스크린 공간 안에 얼마나 많은 픽셀이 압축되어 있는가를 의미.
- `1x`, `2x`와 같은 기기 픽셀 비율(`DPR`, Device Pixel Ratio)로 표현.
  - 단위 길이 안에 존재하는 픽셀의 개수를 상대적으로 나타내는 단위.
- 모니터나 TV의 화소 밀도는 보통 인치당 픽셀 개수인 `PPI`(Pixel Per Inch)로 표현.
  - `10PPI`: 1인치 안에 10개의 픽셀
  - 화소 밀도가 높을 수록 더 선명한 화면을 표현.
- 포인트: `1x`에서는 40픽셀, `2x` 80픽셀의 너비를 가진 이미지를 뜻함.

> 웹 디자이너가 하나의 이미지를 사용할 때 디스플레이를 고려해 여러 크기의 이미지들을 모두 준비해야 함.

- 이러한 이미지의 특성은 웹 사이트의 성능에서 가장 중요한 역할을 함.
- `Hero` 이미지(대문 이미지): 사용자가 사이트에 처음 접속해서 보는 가장 크고 특색 있는 이미지.
  - 사용자는 `Hero` 이미지를 보는 순간 홈페이지가 대부분 로딩되었다 느끼고 나머지 리소스들을 기다릴 여유가 생김.
    > 이러한 `Hero` 이미지들이 홈페이지에서 가장 늦게 로딩된다면 사용자가 답답함을 느껴 금세 경쟁사의 웹 페이지를 찾아갈 확률이 높아짐.

> 이미지는 모든 웹사이트의 기능과 성능 면에서 중요한 역할.

---

## 디지털 이미지의 종류와 특성

- 이미지를 잘 사용하기 위해선 이미지의 종류와 특성을 파악, 사용될 기기 타입과 용도에 맞춰 적절한 이미지 선택.
- `PNG` 파일은 알파 채널(alpha channel)이라는 이미지 변환 기법을 사용.
- 알파 채널은 핵심 이미지 레이어를 제외한 배경 이미지 레이어를 제거하여 전체 이미지를 투명하게 만들어 사용할 수 있는 장점.
  - 투명 기능이 필요하지 않다면 `JPEG` 타입으로 변환해 사용하는 것이 사이트의 성능을 위한 더 나은 선택.
  - 두 이미지가 같은 해상도의 거의 유사한 품질임에도 `JPEG`가 `PNG`의 이미지 크기보다 약 `1/4` 정도 줄어듬.

> `KissMetric`의 연구 결과에 따르면, 페이지 로딩 시간이 1초 느려질 경우 상품을 구매하는 사용자의 비율아 약 `7%` 감소할 가능성 제시.

> 이미지 형식의 종류와 특성을 잘 파악하고 사용 목적 및 기기에 맞는 이미지를 선택하는 것이 웹 성능 향상 뿐만 아니라 비즈니스에서 도움.

### 레스터 이미지 vs 벡터 이미지

- 레스터 이미지
  - 대부분의 이미지 유형.
  - 작은 사각형 모양의 픽셀에 표현하고자 하는 색상 정보를 입력해 이를 컴퓨터로 표현하는 방식.
  - 각각의 픽셀들이 모여 하나의 큰 이미지를 완성.
  - 사이즈가 크거나 품질이 더 좋은 이미지를 만들기 위해서는 그만큼의 정보를 담은 픽셀들을 추가해야만 컴퓨터가 이를 정상적으로 표현.
    > 확장성은 떨어짐.
- 벡터 이미지
  - 그리고자 하는 대상의 수학적인 정보를 제공.
  - 그림이 위치할 좌표나 원 또는 사각형 등의 형상, 크기, 색상 등의 정보를 제공하여 컴퓨터가 마치 그림을 그리듯 화면에 표현.
  - `.svg` 확장자를 가진 `SVG` 파일이 `W3C` 표준 포맷으로 가장 많이 사용됨.
  - 메타 정보를 담고 있으므로 화면이 커지거나 작아진다고 해서 정보가 달라지지 않음.
  - 화면 스케일에 상관없이 항상 선명한 이미지 표현 가능.
    > 복잡해지면 이를 표현하기 위한 정보가 기하급수적으로 늘어나며 수학적인 정보로 표현하는 데에도 많은 제약.
- `SVG` 파일
  - 텍스트 기반 컨텐츠이므로 `gzip`이나 `brotli` 같은 텍스트 압축 기법으로 간단히 최적화 가능.
  - `zopfli` 압축 기법으로 `svgz` 파일을 만들어 사용 가능.

> 다양한 타입의 이미지들이 레스터 형태 기반으로 만들어짐.  
> 레스터 이미지에는 네트워크 전송용 이미지, 향상된 압축 기법으로 최적화된 이미지와 다양한 기능들을 제공하는 최신 형식의 이미지 등 친근한 형식들이 있음.

### 무손실 이미지 형식 vs 손실 이미지 형식

- 무손실 이미지: 원본 이미지의 정보 손실을 허용하지 않음.
- 손실 이미지: 필요에 따라 이동할 수 있는 형태를 만들기 위해 정보 손실을 어느 정도 허용.
- 디지털 카메라로 사진을 찍어 저장한 `RAW` 형식
  - 모든 색상 정보와 빛의 정보가 그대로 저장되므로 크기가 큼.
  - 인터넷에서 관리하고 전송하기 어렵기 때문에 적절한 압축 기법을 이용해 사이즈를 축소하여 저장.
  - 이 과정에서 많은 이미지 정보가 삭제됨.
    - 눈에 띄는 품질 손상을 가져올 수 있음.
- 손실 이미지 형식은 단순 복사를 하거나 저장할 때도 정보 손실이 발생할 수 있으니 주의해야 함.

### 무손실 이미지 형식

#### `GIF`(Graphic Interchange Format)

- `GIF`는 인터넷이 활성화된 이래 가장 처음 등장한 이동식 이미지 형식.
- 아직까지도 널리 사용.
- 몇 개의 이미지를 묶어 짧은 움직임을 표현하는 애니메이션 기능을 제공해 많이 활용.
- 초창기 형식이기 때문에 `8bit` 컬러(256)로 매우 제한적.
- 트루 컬러 타입(true color type)인 `GIF` 이미지로 변형하여 사용할 수 있지만 파일 사이즈가 기하급수적으로 커져 비효율적.

> 화려한 색상의 복잡한 이미지보다 기업의 로고 같은 다소 단순한 형태의 이미지 표현에 적합.

#### `PNG`(Portable Network Graphic)

- `8bit` 컬러만 사용할 수 있는 `GIF`의 단점과 특허 문제를 해결하기 위해 개발.
- `24bit` 컬러(16,777,216)를 사용하므로 `GIF` 보다 고품질 이미지를 표현.
- 웹 사이트에는 알파 채널이라고 불리는 투명 기능 때문에 `PNG`가 많이 사용.
  - 이 기능으로 백그라운드 투명도를 조절해 하나의 이미지에 여러 배경을 바꾸어 다양하게 조합 가능.
- `PNG` 형식
  - 컬러 팔레트 `PNG`
  - 트루 컬러 `PNG`(대부분의 웹 사이트에서 사용)
    - 알파 채널이 추가.

### 손실 이미지 형식

#### `JPEG`(Joint Photographic Experts Group)

- 사진을 저장하는 사실상의 표준 형식.
- `RAW` 형식 파일의 크기 문제를 극복하기 위해 개발.
- 사람의 눈이 인식할 수 있는 색상만 남기고 나머지를 제거하는 방식의 기술을 이용하여 이미지를 표시하는 데 필요한 정보를 줄임.
- 고해상도 이미지를 크게 압축한 파일로 저장 가능.
- 사용자가 품질 값을 `0~100`으로 설정할 수 있지만, 값을 `100`으로 설정해도 약간의 품질 손실이 발생.
  - 따라서 동일한 이미지를 여러 번 편집해야 하는 경우 비트맵이나 `PNG` 처럼 무손실 이미지 파일을 사용하고, 편집을 완료하면 `JPEG`로 저장하는 것을 권함.
- `JPEG` 형식은 `PNG`나 `GIF`에 비해 사진 이미지에 가장 적합한 형식으로써 디지털 카메라에도 널리 사용.
- 압축률이 높아 `PNG` 파일보다 크기가 훨씬 작지만, 투명 기능이나 애니메이션 기능을 지원하지 않음.

#### `JPEG 2000`

- `JPEG`의 단점을 보완하려고 새롭게 개발한 이미지 형식.
- `JPEG`의 압축 방식과 달리 새로운 방식을 사용하여 이미지 압축률을 높임.
- 무손실 압축, 투명 기능, 애니메이션 기능 및 `16bit`, `24bit`, `32bit` 등 다양한 색상을 지원.
  - 다양한 기능이 포함된 만큼 다른 형식들에 비해 더 많은 프로세싱 자원이 필요.
- 대부분의 브라우저에서 지원하지 않음.

#### `WebP`

- 구글에서 개발하고 배포한 이미지 형식.
- `JPEG`보다 개선된 공격적 압축 방식을 사용하여 파일 크기를 `25%~33%` 정도 작게 만들 수 있음.
- 무손실 압축, 투명 기능, 애니메이션 기능도 모두 지원.
- 다른 이미지 형식들에 비해 압축률이 높지만 이미지 품질을 많이 낮추면 화질에 약간 손실이 발생.
  - 흰색이나 검은색 등 단색의 모서리 부분에 많은 결점을 보이기도 함.
- `JPEG`와 같은 점진적 데이터 전송 기능은 갖추지 못함.
- 일반적인 환경에서는 `JPEG` 보다 전체 파일 크기가 작은 `WebP`를 사용하는 것이 유리함.

> 사용자의 네트워크 품질이 낮은 경우를 고려한다면, 점진적 데이터 전송 기능이 빠진 점은 아쉬움.

#### `JPEG XR`(`JPEG` eXtended Range)

- 마이크로소프트에서 개발.
- `JPEG`에 비해 `R/G/B`에 해당하는 색상 채널 당 더 많은 수의 채색을 허용해서 표현할 수 있는 색상의 범위 확장.
- 향상된 압축 기법으로 파일 크기를 크게 감소시킬 수 있 음.
- 무손실 압축, 투명 기능을 지원.
- 점진적 데이터 전송 기능도 지원.
- 마이크로소프트 사의 브라우저에서만 지원.

---

## 이미지 변환 기법

### 무손실 압축

- 무손실 압축을 하려면 각 이미지 유형을 다르게 처리해야 함.
- 대체로 스크립트를 통해 압축을 자동화할 수 있다는 장점.

#### `GIF`

- `ImageMagicK`
- `Giflossy`
- `Gifsicle`
- `gif2webp converter`

#### `PNG`

- `PNG` 임을 알리는 구분자인 첫 `8Byte` 서명을 제외하고 청크(`chunk`) 형태로 이미지 정보를 저장.
- 이미지 정보를 저장하는 것은 핵심 청크.
- 히스토그램 관련 데이터나 이미지가 `Adobe Photoshop` 같은 소프트웨어에서 작성되었음을 알려주는 정보성 청크 등 사용자 정의 청크 추가 가능.
  - 대부분의 웹 렌더링에 필요하지 않으므로 삭제 가능.
- `Pngcrush`
- `Pngquant`
- `OptiPNG & Zopfli`
- `PngOptimizer`

#### `JPEG`

- 이미지 정보 외에도 많은 메타 데이터가 포함되어 있음.
  - 주석 및 공백
  - `Adobe Photoshop` 같은 편집 애플리케이션 정보
  - 카메라 제조사 및 모델, 사진 촬영 날짜, 사진 위치 정보, 축소판 또는 오디오와 같은 `EXIF`(EXchangeable Image File Format) 정보
- 이 정보들은 이미지의 세부 정보를 알고 싶을 때는 유용하지만, 웹 상에서 이미지를 표시할 때 필요 없음.
- 따라서 삭제하면 이미지 품질 손실 없이도 파일 크기를 줄일 수 있음.
- `MozJPEG`
- `libJpeg`
- `Guetzli`

### 손실 압축

- 특정 이미지 정보를 누락. 즉, 손실시켜 파일 크기를 줄이는 방법.
- 사람의 시각은 명암 차이에 민감하지만 채색 차이에 크게 민감하지 않음.
  - 따라서 이미지 색이 비슷한 부분을 하나의 색으로 통일해 그만큼의 정보를 손실 시켜도 사용자는 눈치채지 못함.
- 손실 압축은 원하는 만큼의 화질을 얻지 못하는 위험이 있으므로 고화질의 사진을 저장해 감상하고 싶다면 손실 압축을 피해야 함.
  - 하지만 웹 상에 게시하고자 한다면 성능과 화질 사이 득실을 따져봐야 함.
- 대부분의 웹 사용자들은 이미지의 화질보단 로딩 속도에 민감하게 반응.
  > 손실 압축 기법을 잘 활용하면 사용자 경험 개선 가능.
- 단조로운 색의 이미지라면 손실 허용률이 클 수 있음.
  > `Imgmin` 프로젝트에 의하면 사람이 품질 저하를 거의 눈치채지 못하면서 파일 크기를 가장 크게 줄일 수 잇는 `JPEG` 품질은 `100~75%` 사이.
  >
  > > 대부분의 이미지는 `75%` 품질로도 브라우저에서 문제없는 화질로 보임.
- 손실 압축을 하려면 기존 이미지 형식을 디코딩한 후 알고리즘에 따라 원하는 화질로 저하시켜 다시 원래 이미지 형식으로 인코딩.
- `ImageMagicK` 사용 예시
  ```sh
  $ convert input.jpg -quality 80 output.jpg
  $ convert input.jpg -quality 80 output.jpg
  ```

#### 적절한 손실 압축 품질 지수

- 사용자의 경험을 해치지 않고 파일 크기를 줄일 수 있는 최적 품질 수준은 각 이미지의 특성에 따라 달라짐.
- 손실 압축을 위한 최적의 품질 지수를 찾기 위해서는 원본 이미지와 손실 압축 이미지의 시각적 차이를 정량 계산할 수 있는 방법이 필요.
- 두 이미지 간 차이를 정량적으로 수치화해 표현하려는 알고리즘
  1. 평균 제곱 오차(`MSE`, Mean Sqared Error)
  2. 최대 신호 대 잡음 비(`PSNR`, Peak Signal to Noise Ratio)
  3. 구조적 유사도(`SSIM`, Structural Similarity)
- `SSIM`은 사용자 겸헝을 최대화하기 위한 이미지 최적화에 유용하게 사용 가능.
- 사용자의 웹 경험은 이미지의 품질과 비례하지 않으며, 오히려 이미지의 품질이 좋아지면 파일의 크기가 커져 다운로드 시간이 길어져 사용자 경험이 저하될 수 있음.
  > 따라서 `SSIM` 값을 최대화할 수 있는 품질 지수를 찾아 손실 압축하는 것이 사용자 경험을 최대화 하는 방법.
- 같은 화질에 이미지라고 해도 손실 압축에 사용되는 라이브러리와 이미지 형식에 따라 `SSIM` 값이 달라질 수 있음.
  - `DSSIM`는 `SSIM`과는 반대로 `0`에 가까울수록 원본에 근접.
  - 같은 화질 수준이라도 라이브러리 별로 `DSSIM` 값에 차이가 있음을 알 수 있음.
  - 원본과 최대한 유사성을 가지는 화질을 찾는 것이 목표이므로 특정 `DSIMM` 값에 대응하는 품질 수준을 이미지 형식과 라이브러리 별로 찾아 적용해야 함.
    > `DSSIM` 값은 사용자의 기기 또는 브라우저 종류나 해상도와 화소 밀도에 따라 다르게 지정하는 것이 이상적.

#### 시각적 인지 능력을 고려한 자동 최적화 도구

- 이미지 화질은 원본 이미지의 정보 뿐만 아니라 브라우저 종류, 화면 해상도, 화소 밀도, 네트워크 다운로도 속도 등 사용자의 웹 환경도 고려해 결정해야 함.
- 또한 웹 사이트 내 모든 이미지 파일에 적용하려면 일련의 작업을 자동화해야 함.
- 유료 서비스
  - `Akamai` 같은 `CDN` 서비스 제공 업체에서는 이미지 트래픽 관련 자동 최적화 기능을 제공.
    - 개별 사용자의 화면 크기, `DPI` 등의 정보를 고려하여 적절한 `SSIM` 값에 따라 손실 압축을 수행하고 사용 브라우저에 적합한 이미지 형태로 변환해 전송.
  - `Cloudinary`는 클라우드 상에서 이미지나 비디오를 관리하는 솔루션을 제공.
    - 클라우드 내에서 기기 종류에 맞도록 이미지나 비디오를 자동 최적화한 후 제휴된 `CDN`을 통해 빠르게 전송.
  - `JPEGmini`는 오프라인 최적화 도구로, 최적화하려는 이미지들을 끌어다 놓으면 최적의 품질로 손실 압축.
    - 대량의 이미지를 최적화하는 데 유용하지만 오프라인 도구이므로 웹 사용자의 환경 정보는 고려 불가.

#### 브라우저 특화 이미지로 변환

- 최근 사용되는 기술적으로 진보된 이미지 형식들은 지원하는 브라우저가 달라 변환하기 어려움.
- 따라서 모든 사용자의 웹 경험을 향상시키려면 하나의 이미지를 만들더라도 다양한 브라우저 특화 이미지 형태로 변환시켜 제공해야 함.
  - `WebP`
    - `libwebp`는 구글에서 제공하는 `C` 라이브러리.
    - `WebP`를 인코딩, 디코딩 하는 기능을 제공.
    - 인스톨 후 `80%`의 손실 압축으로 `WebP`를 생성하는 명령어
      ```sh
      $ cwebp -q 80 image.png -o image.webp
      ```
    - 반대로 `WebP`를 다른 이미지 형식으로 전환하는 명령어
      ```sh
      $ webp image.webp -o image.png
      ```
    - `ImageMagickK`도 `WebP` 변환을 지원(내부적으로는 `libwebp` 라이브러리를 사용)
      ```sh
      $ convert input.png output.webp
      ```
  - `JPEG 2000`
    - `OpenJPEG` 프로젝트에서는 `JPEG 2000` 이미지를 인코딩, 디코딩하기 위한 `C` 라이브러리 그리고 관련 도구를 제공.
  - `JPEG XR`
    - 마이크로소프트사는 구글, `OpenJPEG` 처럼 `jxrlib`이라는 라이브러리와 이를 포함한 도구를 제공.

---

## 반응형 웹에서의 이미지 배치 전략

- 모바일 사용자들의 인터넷 웹 사이트 접속이 증가하면서 웹 사이트의 구현 추세에도 변화가 생김.
- 처음에는 모바일 전용 사이트를 별도로 구축하여 기존의 데스크톱용 도메인인 `www` 부분만 `m`으로 바꾸어 사용.(엠닷 사이트)
  - 모바일 기기의 크기가 다양해지면서 엠닷 사이트 하나만으로는 모든 기기의 사용자들을 만족시킬 수 없게 됨.
  - 유지 보수 문제
    - 비용과 시간을 두 배로 투자해야 하는 효율 저하.
  - 모바일 사용자의 사용성 문제.
    - 유지 보수가 어려워짐에 따라 몇 가지 중요한 기능들이 누락.
    - 페이지 구조나 `UI/UX`도 다소 달라져 사용자들이 불편을 겪게 됨.
- 이에 반응형 웹이라는 개념이 등장.
- 반응형 웹이란, TV, PC, 태블릿, 스마트폰 등 각종 기기가 제공하는 화면 크기에 맞추어 최적화된 웹 페이지를 제공하는 것.
  - 반응형 웹을 사용하면 유지 보수의 필요성, 모바일 사용자의 사용성, `SEO` 이점 등을 제공.
    - 구글에서는 반응형 웹을 사용한 웹 사이트에 `Mobile-Friendly`라는 타이틀과 함께 검색 우선 순위를 높이겠다 공언.

### 반응형 웹의 문제점

- 반응형 웹은 다양한 기기에서 똑같은 사용자 경험을 제공한다는 장점이 있었으나, 성능 측면에서 효과적이지 못함.
- 모바일 환경은 데스크톱 환경에 비해 열악하여 페이지 로딩 시간도 느려짐.
  - `LTE` 환경에서 케이블에 비해 절반 정도의 데이터 처리, 2배 정도의 시간 지연이 발생.
- 데스크톱에 비해 모바일 기기의 `GPU`, 메모리 등의 사양이 좋지 않아 모바일 환경에서 페이지 로딩 시간은 더 길어질 것.

> 모바일 사용자를 위해 도입된 반응형 웹이 오히려 성능 저하로 인해 사용자 경험의 질을 저하시키는 모순이 발생.

> 화면의 크기나 사용하는 기기가 바뀌어도 웹 사이트의 무게가 변하지 않는다는 문제점.

### 원인은 이미지

- 사용자의 웹 환경에 따라 변하지 않는 이미지의 크기가 문제.
- 반응형 웹을 만들 때 가장 기본은 주 사용자들의 기기 종류를 고려하여 브레이크 포인트. 즉, 사이즈가 변화하는 지점을 정의하고 그에 맞추어 화면을 디자인하는 것.
  - 이때 반응형 웹의 기본 기술이 미디어 쿼리(`media query`), 가변 그리드(`fluid grid`), 유동형 이미지(`flexible image`) 등의 기술이 적용.
  - 미디어 쿼리가 사용자의 환경을 감지, 가변 그리드가 페이지 레이아웃을 구성하면 그 안의 이미지가 자동으로 확장/축소되면서 화면에 적절히 표현.
- 이미지는 큰 화면에서도 선명하게 보이도록 가장 높은 해상도 이미지를 사용하게 됨.
  - 그러나 화면에 크기에 맞추어 이미지가 작아지더라도 파일의 크기는 작아지지 않음.
- 이처럼 화면이 작아졌는데도 필요 이상의 웹 리소스들을 과하게 내려받는 현상을 `over-downloading`이라 함.

#### 내려받아 줄이기(download and shrink)

- 반응형 웹 개발을 위한 기본 기술: 유동형 이미지
- 일반적인 웹 페이지를 개발할 때는 사용될 이미지의 `가로x세로`를 파악하여 적절한 크기의 이미지를 미리 준비.
  - `HTML`의 `<img>` 태그에 준비된 이미지가 있는 위치와 함께 지정된 `width`, `height`를 정의.
    > `width`, `height`를 명시하지 않고 코드를 작성하면 브라우저의 처리 성능을 저하.
- 반응형 웹에서는 화면의 크기가 변할 때마다 나타나는 이미지의 `가로x세로` 크기가 달라지기 때문에 고정된 값을 사용할 수 없음.
  - 따라서 고정 값 대신 전체 화면 대비 이미지 영역의 비율 값 사용.
    - 이 영역에 링크된 이미지 크기가 비율에 맞추어 자동으로 변하기 때문에 이를 유동형 이미지라 부름.
- 유동형 이미지는 편리한 기능을 제공하지만, 이미지 크기가 작아진다고 해서 실제 이미지가 작아지지 않기 때문에 문제 발생.
- 실제로는 브라우저가 큰 이미지를 다운로드해 작게 축소하는 처리를 하며, 이때 실시간으로 계산하는 추가 과정이 필요.

> 결국 모바일 환경에서는 과도하게 큰 이미지를 다운로드하려고 네트워크를 낭비, 이미지를 축소하는 처리 리소스와 시간을 낭비하는 문제점.

#### 내려받아 숨기기(download and hide)

- 데스크톱 화면에는 모바일 화면에서는 불필요한 리소스들이 존재.
  - 이 불필요한 리소스들이 모바일 환경에서도 여전히 다운로드되는 데서 문제 발생.
- `display: none;` 등의 `CSS`로 화면에 숨겨지는 리소스들이라도 `HTML`에 정의된 리소스들을 대부분 그대로 다운로드한 후에 `CSS`에 의해 화면에 표현할지만 결정하므로, 네트워크 리소스를 차지.

> 브라우저는 `CSS`에 의해 숨겨진 이미지들도 모두 다운로드해 필요 이상으로 네트워크 자원을 소모하면서 로딩 시간을 지연.

#### 화면 바깥 부분(`below the fold`)

- 사람들에게 보이는 부분을 `above the fold`, 반으로 접혀서 보이지 않는 부분을 `below the fold`라고 함.
- 화면 바깥 부분의 이미지들은 화면에 보이지는 않지만 모두 다운로드됨.

> 화면 바깥쪽 이미지들을 다운로드하기 위해 너무 오랜 시간이 허비된다면 전체 페이지 로딩 시간이 늦어지고, 화면 안쪽 부분의 로딩 시간에도 영향을 줌.

> 궁극적으로 사용자의 웹 경험을 저하시킴.

### 반응형 이미지

> 반응형 웹의 문제점은 모바일 환경에서 필요하지 않은 리소스들을 과도하게 다운로드한다는 것.

- 과도한 다운로드는 `HTML`, `JavaScript`, `CSS`, 이미지 등 모든 리소스에서 나타나는 현상.
  - 이 중 이미지 다운로드가 가장 큰 원인?
- 반응형 이미지: 사용자의 환경에 따라 그 환경에 적합한 상태로 변경해 제공되는 이미지.
  - 사용자가 특정 환경에서 특정 이미지를 요청하면 그 환경에 맞도록 이미 변경된 이미지가 전송되는 것.
  - 이를 통해 과도한 이미지 다운로드 문제 방지 가능.

### 반응형 이미지 구현 방법

1. 프론트엔드 측면에서의 구현
   - 미디어 쿼리를 사용해 클라이언트 환경을 파악한 후 그 환경에 맞는 이미지 파일을 호출하도록 웹 페이지를 구현.
   - `<img>` 태그의 `srcset` 속성이나 `<picture>` 태그를 사용해서 표준 방식으로 비교적 쉽게 구현 가능.
   - 과도하게 사용할 경우 프론트엔드 코드가 무거워져 성능에 악영향.
2. 백엔드 측면에서의 구현
   - 서버에서 클라이언트 환경에 맞는 이미지를 선택하여 전송하는 방법.
   - 프론트엔드 코드가 추가되지 않으므로 사이트의 성능 향상 가능.
   - 클러이언트의 환경을 정확히 판단하기 어려운 과제가 있음.
   - 서버 측 프로그램이 추가되어야 하는 번거로움도 있음.
   - 정확한 클라이언트 환경을 서버에 전달하기 위해 `Client Hints`를 이용 가능.

#### `srcset`과 `size` 속성

- `srcset`은 `HTML`의 `<img>` 태그의 속성으로 사용자의 다양한 환경에 다라 다른 이미지 `URL`을 지정할 수 있도록 함.
  ```html
  <img
    src="small.jpg"
    alt="rwd"
    srcset="pic-normal.jpg 1x, pic-retina.jpg 2x"
  />
  ```
  - 레티나 디스플레이(Retina display) 같은 고해상도 화면 기기에서는 `pic-retina.jpg`가 선택.
- `size` 속성으로 브레이크 포인트에 따른 이미지 크기를 지정 가능.
  ```html
  <img
    src="small.jpg"
    alt="rwd"
    srcset="pic-200.jpg 200w, pic-400.jpg 400w"
    size="(mac-width: 400px) 100vw, (max-width: 800px) 30vw, 300px"
  />
  ```
  - `size` 속성을 사용할 때는 화소 밀도 정보가 아닌 `width` 정보를 정의해야 함.
- `srcset`은 브라우저에게 가장 적절한 이미지를 선택하도록 힌트를 주는 역할.
- 브라우저가 사용하는 연산 방식이나 메모리, 혹은 파워가 충분한지에 따라 낮은 해상도 이미지가 선택될 수도 있음.
- `srcset`은 내려받아 줄이기 문제를 어느정도 해결해 주지만 완벽하게 지원하진 않음.
  - 해상도별로 다른 비율의 이미지를 사용하거나 부분만 확대한 이미지를 사용할 경우 이미지가 비정상적으로 보일 수 있음.

> 따라서 동일한 이미지를 크기만 다르게 사용할 것을 권함.

#### `<picture>` 태그

- `<picture>` 태그는 `srcset`의 단점을 모두 보완.
- 내부적으로 `<source>` 태그를 사용해 다양한 이미지 `URL`을 설정하게 함.
  - 이때, 미디어 쿼리를 사용해 각 `URL`의 로딩 조건을 구체적으로 정의 가능.
- 정의된 조건에 맞는 이미지만 사용하도록 브라우저를 강제할 수 있으며 조건에 맞지 않는 이미지는 다운로드하지 않음.
  > 내려받아 숨기기와 내려받아 줄이기 문제를 모두 해결하는 가장 효과적인 방법.
  ```html
  <picture>
    <source media="(min-width: 45em)" srcset="large.jpg, large-hd.jpg 2x" />
    <source media="(min-width: 18em)" srcset="med.jpg, med-hd.jpg 2x" />
    <source src="small-1.jpg" alt="rwd" />
  </picture>
  ```
- `<picture>` 태그를 사용하면 `HTML` 소스가 다소 길어지며, 모든 브라우저가 지원하지 않는다는 단점 존재.
  - `<img>` 태그의 `srcset`은 특정 브라우저에서 지원하지 않아도 `src` 속성에서 이미지 `URL`을 참조할 수 있어 오류가 발생하지 않음.
  - `<picture>` 태그는 브라우저가 지원하지 않으면 정의된 이미지 다운로드 불가.
- 특정 기능을 지원하지 않는 브라우저에서도 사용할 수 있도록 코드 조각이나 플러그인. 즉, `polyfill`이 많이 공개되어 있음.
  - `Picturefill` 등.

#### `Art direction`

- 반응형 이미지가 사용자 환경에 따라 자동으로 변하지 않는다는 단점은 여전히 존재.
  - 하나의 원본 이미지에 화면 크기별, 해상도별, 브라우저별로 적합한 이미지들을 만드는 시간과 노력이 필요.

> `Art direction`: 같은 이미지를 크기만 다르게 하는 것이 아니라, 이미지의 특징이나 가치가 기기 특성에 따라 표현되도록 정교한 작업이 이루어지는 것.

- 드러내고자 하는 이미지에 따라 `scale`을 조절하는지, `crop` 기능을 통해 적합한 이미지를 만들 것인지 고려해야 함.
- `Art direction`을 적용하려면 개발 및 운영에 많은 시간과 비용이 요구.
- `Adobe`에서는 `Scene7`이라는 도구를 통해 원본 이미지를 동적으로 쉽게 편집하고 웹에 배포할 수 있는 기능 제공.

#### `Client Hints`

- 웹을 사용하는 기기나 소프트웨어들이 다양해짐에 따라 모든 처리를 브라우저에만 맡기기 어려워짐.
- 웹페이지를 호스팅하는 서버에서 사용자 환경을 고려해 응답할 내용을 최적화한 후 브라우저에 전달하는 방안이 도입.
- 이때 사용자 환경을 서버에 표준 방식으로 전달하기 위해 `Client Hints`를 사용하도록 논의 중.
  - `HTTP Working Group`에서 구글의 주도 하에 `Internet-Draft` 버전으로 논의를 진행 중이며 실제 사용하는 표준은 아님.
  - 많은 브라우저에서 지원하므로 필요에 따라 사용 가능.
- `Client Hints` 헤더는 `HTTP` 헤더의 일부로 포함되어 전송.
  - 서버는 이 정보를 기반으로 응답 내용을 최적화해 다시 브라우저에 전송 가능.
    > 일반적인 내용 협상(content negotiation)과 동일한 방식.  
    > `Aceept-Encoding` 헤더가 이러한 내용 협상 방식에 속함.
- 동작 과정
  1. 브라우저에서 최초 서버로 `HTTP` 요청을 보냄.
  2. 서버는 응답 헤더에 `Accept-CH`를 추가해 `Client Hints`를 지원하고 있음을 브라우저에 알림과 동시에 필요한 정보를 보내줄 것을 요청.
     ```shell
     Accept-CH: DPR, Width, Viewport-Width
     ```
  3. 브라우저에서는 하위 리소스에 대한 요청부터 관련 정보를 헤더에 추가해 보냄.
     ```shell
     DPR: 2.0
     Width: 320
     Viewport-Width: 320
     ```
  4. 서버는 최적화된 이미지를 전송한 후 사용한 `DPR` 정보를 마지막 응답 메세지로 보냄.
     ```shell
     Content-DPR: 1.0
     ```
  5. 이 `DPR` 정보는 브라우저가 서버로부터 받은 이미지를 처리할 때 사용.

#### 이미지 지연 로딩

- `below the fold` 문제는 웹 성능을 저하.
  - 이미지가 많고 무거울수록 네트워크 대역폭을 많이 소모.
  - 중요한 리소스들의 다운로드를 지연.
- `below the fold` 문제를 해결하기 위해 `JavaScript`를 사용한 지연 로딩 방법 사용 가능.
- 지연 로딩의 간단한 예시 코드
  ```html
  <script>
    function loadReal(img) {
      if (img.display != "none") {
        img.onload = null;
        img.src = img.getAttribute("data-src");
      }
    }
  </script>
  <img src="1px.gif" data-src="book.jpg" alt="A Book" onload="loadReal(this)" />
  ```
- 실제 상황에서는 이렇게 단순하지 않으므로 `lazyload`와 같은 라이브러리 사용 가능.

#### 모바일 우선 접근

- 데스크톱 우선 방식: 반응형 웹을 개발할 때 데스크톱 화면을 먼저 개발.
- 모바일 우선 방식: 모바일 기기에 적합한 페이지부터 개발.
- 데스크톱 화면을 먼저 개발하면 데스크톱에 최적화된 이미지를 많이 사용하고, 모바일 화면을 개발할 때 데스크톱 이미지들을 상당수 그대로 사용.
  - 이 경우, 모바일 페이지 성능 저하로 사용자 불편을 야기하고 매출 하락으로 이어질 수 있음.

> 모바일 사용자 증가가 예상되는 만큼 모바일 우선 접근법을 사용해야 할 수도 있음.

---

## 적응형 이미지 전략

- 반응형 웹은 모든 클라이언트 환경에 같은 웹 페이지로 대응.
  - 따라서 파일 사이즈가 커지고 복잡해지는 또 다른 문제점.
  - 또한, 이미지 성능을 위해 뷰포트, 스크린 사이즈, 화소 밀도, 브라우저 등 변수를 고려해야 함.
    > 하나의 이미지를 다운로드하기 위한 코드가 늘어나고 이미지가 많아질 수록 웹 페이지의 크기가 커짐.  
    > 결국 사용자 기기에도 부담을 늘림.
- 모바일 기기의 인터넷 속도는 데스크톱에 비해 느리고, 데이터 용량에도 제한이 있음.
  - 따라서 데스크톱과 똑같은 대용량 웹 페이지를 그대로 내려받는 것은 비효율적.

> 이를 해결하고자 서버 측 반응형 웹 접근 방법 등장.

- 서버 측 반응형 웹 접근 방법: 서버에서 클라이언트의 정보를 파악해 맞춤형 페이지를 생성하여 전송.
  - 일반 반응형 웹: 서로 다른 기기별 요청에 동일한 대용량의 응답을 다운로드하고, 클라이언트 측에서 화면 크기에 맞게 콘텐츠를 적용.
  - 서버 측 반응형 웹: 기기별 요청을 서버에서 감지하고 각 기기에 적합한 콘텐츠를 만들어 응답.
- 적응형 이미지는 서버 측 반응형 웹을 구현할 때 필수적인 이미지 호출 방식.
  - 방문자 기기 종류, 화면 크기 등을 감지하고 해당 `HTML`에 맞는 이미지를 자동으로 선택해 전송.

### 적응형 이미지 아키텍처

- 적응형 이미지 아키텍처에서 가장 근본적이고 중요한 부분은 클라이언트의 정보를 어떻게 감지하느냐.
- 반응형 웹에서는 미디어 쿼리를 사용해 클라이언트의 정보를 쉽게 감지하여 반응형 로직을 수행 가능.
- 서버 측 반응형에서는 `HTTP` 요청 정보 외에 클라이언트의 정보를 알 길이 없음.
  - `HTTP` 요청에 `Client Hints`에 클라이언트 정보가 추가되어 담길 예정이지만 실제 사용까지 시간이 걸림.
  - `HTTP`의 `User-Agent` 헤더를 통해 클라이언트의 정보를 알 수 있음.
  - `User-Agent`에는 브라우저 정보, 버전, 플랫폼, 시스템, 그리고 기타 사용자 정보 등이 담겨있음.
    ```shell
    # User-Agent 형식

    # 일반적인 형식
    User-Agent: <product> / <product-version> <comment>

    # 브라우저 형식
    User-Agent: Mozilla/<version> (<system-information>) <platform> (<platform-details>) <extensions>

    # 예시
    User-Agent: Mozilla/5.0 (iPad; U; CPI OS 3_2_1 like macOS X; en-us) AppleWebkit/531.21.10 (KHTML, like Gecko) Mobile/7B405
    ```
- 원본 서버 앞에 리버스 프록시 서버 또는 애플리케이션을 두고, `User-Agent` 값을 기반으로 필요한 정보들을 수집해 사용자 정의 헤더나 쿠키에 넣어 서버로 보낼 수 있음.
- 뷰포트, 스크린 크기, 화소 밀도 등의 정보는 기기를 감지해 정보를 제공해주는 여러 가지 솔루션을 사용 가능.
  - `DeviceAtlas`, `ScientiaMobile/Wurf`, `51degree` 등.
  - 관련 라이브러리를 제공하거나 클라우드 서비스로 기기 정보들을 제공하며 주기적으로 데이터베이스를 업데이트.
  - 무료로 배포되는 라이브러리는 찾기 어려움.
- `CDN` 서비스를 사용한다면 부가적으로 제공되는 기기 검출 서비스를 고려해볼 수 있음.
- `Modermizr.js`와 같은 클라이언트 측 `JavaScript`로 장치 탐지를 수행 가능.
  - `JavaScript`가 로딩되어야 하므로 `JavaScript`가 포함된 첫 번째 페이지를 로딩할 때는 사용 불가.
  - 첫 번째 페이지에 이미지 링크가 많이 포함되어 있다면 피해야 할 방법.
  - 사이트 이미지를 지연 로딩하고 있다면 이러한 기기 검출 스크립트를 사용해 필요한 시점에 관련 정보를 보낼 수 있음.

### 기기 정보에 따라 서버 로직 수행

- 기기 검출 방안에 따라 관련 정보들을 수집했다면 클라이언트 환경에 맞는 이미지 파일을 링크에 연결.
  1. 브레이크 포인트를 사전 정의.
     - 브레이크 포인트를 정의했다면 이에 맞추어 이미지들을 미리 준비.
  2. 검출된 기기의 너비를 추출.
  3. 추출한 너비가 어떤 브레이크 포인트보다 작다면 그 포인트에 해당하는 이미지를 로드.
- 국내의 많은 웹 사이트들을 대부분 모바일, 태블릿, 데스크톱에 해당하는 3개 포인트를 설정.
  - 이 정책은 사이트 성능을 얼마만큼 개선할지에 맞추어 변경해야 함.

```php
// Pseudo Code
$breaks = array(100, 400, 800, 1000, 1200, 1400);

// 기기 검출 솔루션으로부터 스크린 너비를 추출
$app1 = loadApp("cookie_wurfl");
if (array_key_exists("screen_width", $_COOKIE)) {
  $cookie_screen_width = $_COOKIE["screen_width"];
  $width = $cookie_screen_width;
  $this->cookie_exists = true;
}

// 브레이크 포인트 찾기
foreach ($breaks as $point) {
  if ($width <= $point) {
    $img_width = $point;
  }
}

// DPR 적용
$img_width = $img_width * $dpr;

// 이미지 크기 설정
$img->setImageSize($img_width);
```

### 브라우저별 이미지 전달

- 브라우저별 이미지는 `HTTP` 요청의 `Accept` 헤더를 참고해 결정 가능.

```shell
# Google Chrome 'Accept' 헤더
accept: image/webp,image/apng,image/*,*/*;q=0.8

# Microsoft Edge / Internet Explorer 11 'Accept' 헤더
accept: image/jxr,image/apng,image/*,*/*;q=0.8

# JPEG 2000을 지원하는 Apple Safari는 'Accept' 헤더에 별도 표시를 하지 않으므로 기기 검출 솔루션에 의존
```

```php
// Pseudo Code
if (strstr($_SERVER["HTTP_ACCEPT"], "image/webp") !== false) {
  # WebP로 변환
  $img->setImageFormat("webp");
}

if (strstr($_SERVER["HTTP_ACCEPT"], "image/jxr") !== false) {
  # JPEG XR로 변환
  $img->setImageFormat("jxr");
}

$browser = $app1->capabilities["mobile_browser"];
$browser_ver = $app1->capabilities["mobile_browser_version"];
if ((strstr($browser, "Safari") != false) && $browser_ver >= 6) {
  $img->setImageFormat("jp2");
}
```

### 캐시 고려 사항

- 서버 측 반응형 웹이나 이에 따른 적응형 이미지를 구성할 때 성능을 고려해 이미지를 캐시하는 경우가 많음.
- 적응형 이미지는 동일한 `URL`을 사용해도 사용자 기기에 따라 서로 다른 이미지가 응답될 수 있으므로 캐시 충돌 현상에 주의해야 함.
- 캐시 충돌 현상: 하나의 `URL`에 여러 개의 다른 콘텐츠가 응답할 수 있 을 때 먼저 응답하는 콘텐츠만 캐시되는 현상.
  - 이러한 현상을 피하려면 서버에서 응답할 때 `Vary` 헤더를 활용해서 특정 헤더에 따라 콘텐츠가 달라질 것이라고 캐시 서버에 알려줘야 함.
    ```shell
    # 요청 헤더
    GET /mytest.jpg
    Accept-CH: DPR, Width, Viewport-Width
    DPR: 2.0
    Width: 320
    Viewport-Width: 320
    # (생략)

    # 응답 헤더
    HTTP/1.1 200 OK
    Content-Type: image/jpeg
    Vary: Width
    # (생략)
    ```
  - `CDN` 서비스를 사용한다면 `Vary` 헤더를 사용하는 것보다 `CDN` 서비스에서 제공하는 캐시 키 정책을 수정하여 기기 정보를 추가하면 됨.
    ```shell
    # 데스크톱 이미지의 캐시 키
    feokorea.com/mytest.jpg _cid=width=1280

    # 모바일 이미지의 캐시 키
    feokorea.com/mytest.jpg _cid=width=320
    ```
