# 웹 프로토콜 최적화

## `HTTP`의 발전

- `HTTP/0.9`는 웹 콘텐츠를 요청하는 `GET` 메서드만 존재하고 `HTML`만 읽을 수 있을 뿐, 클라이언트의 정보를 서버에 전달할 방법은 없음.
  - 텍스트 콘텐츠만 열람 가능.
- `HTTP/1.0`부터는 `HTML`을 포함하는 `HTTP` 페이로드 외에도 헤더를 통해 클라이언트와 서버의 정보 전달 가능.
  - `Content-Type` 헤더를 통해 `HTML` 뿐만 아니라 이미지, 동영상 등 정보를 주고 받을 수 있게 됨.
  - `POST` 메서드를 추가하여 클라이언트의 정보를 웹 서버로 전달하는 방법 지원하기 시작.
  - `Content-Encoding` 헤더를 통해 클라이언트 서버 간 압축 정보를 공유하며 `HTML` 등의 스크립트를 압축해 크기를 줄여 전송, 클라이언트는 이를 압축 해제해 브라우징.
    - `POST` 메서드가 추가되면서 클라이언트의 정보를 웹 서버로 전달하는 방법 지원.

### `HTTP/1.1`

- `HTTP/1.1`은 `HTTP`의 첫 번째 공식 표준 버전.
- `PUT`, `DELETE`를 이용해 파일을 업로드하거나 웹 서버의 내용 삭제 가능.
- `Via` 헤더를 사용해 중계 서버 정보를 공유하고 `Accept` 헤더로 클라이언트가 어떤 형식의 콘텐츠를 지원하느지 미리 서버에 알려줄 수 있음.
- 하나의 `TCP` 연결을 재사용해 많은 콘텐츠를 전달할 수 있는 지속적 연결 기술 추가.
- 파이프라이닝 기술: 브라우저가 웹 서버에 여러 개의 콘텐츠를 요청했을 때, 이전 요청에 대한 응답을 완전하게 받지 않더라도 지속적 연결로 확보한 하나의 `TCP` 연결 내에서 미리 다음 요청에 대한 처리를 시작하면서 전체적인 전달 시간을 줄이는 방식.
- `HOL`(Head-Of-Line blocking) 문제: 클라이언트와 서버가 주고받는 통신에는 순서가 있어 서버가 하나의 요청에 응답을 지연하면 나머지 모든 요청 역시 지연되는 문제.

### `HTTP/2`

- `HTTP/1.1`보다 개선된 웹 프로토콜을 만들기 위해 구글이 시작한 `SPDY` 프로젝트.
- 텍스트 방식의 프로토콜 메세지를 과감히 버리고 이진 포맷(binary format)을 사용하면서 프로토콜 자체를 경량화하려고 시도.
- `HTTP/1.1` 기능에 멀티플렉싱, 스트림 우선순위 설정, 헤더 압축(`HPACK`), 서버 푸시 같은 새로운 프로토콜 최적화 기능 추가.
- `HTTP`의 `HOL` 문제를 해결할 수 있었으나, `TCP`의 `HOL` 문제는 해결하지 못함.

### `HTTP/3`

- `QUIC`를 사용하는 `HTTP` 최상위 버전.
- `QUIC`의 가장 큰 특징은 `UDP`(User Datagram Protocol)을 사용한다는 점.
  - `TCP`의 오랜 단점을 `TCP` 프로토콜 내에서 수정하기는 어려웠기 때문.
- `UDP` 프로토콜 구조가 최적화를 진행하기 더 쉬운 형태이기 때문에 `HTTP/3`는 `UDP`를 사용.
- 클라이언트와 `HTTP/3` 서버 사이에 한 번 맺은 `QUIC` 연결을 최대한 재사용하는 구조이므로 클라이언트와 서버 간 연결을 만드는 과정에서 소모되는 시간 대폭 축소.
- 실험적인 프로토콜이지만 가장 강력한 기능과 최적화가 추가된 프로토콜.

---

## `HTTP/2`의 최적화 기술

- `HTTP/2`의 가장 큰 목표는 클라이언트와 서버가 콘텐츠를 주고받는 시간을 줄이고, 서버 응답이 느린 콘텐츠가 다른 정상적인 콘텐츠의 전달을 방해하지 않도록 하는 것.
  - 기존 문자열(text) 방식의 프로토콜을 이진 프레임(binary frame)으로 바꾸어 프로토콜을 좀 더 가볍고 유연하게 만듬.
  - `HTTP` 요청과 응답에 포함된 중복 헤더 값은 걸러내고, 전송해야 하는 값을 기존과 다르게 압축해 헤더의 크기를 최소화.
  - 서버 푸시를 통해 클라이언트가 요청하지 않은 콘텐츠도 서버가 미리 빠르게 전송하여 `RTT` 최소화.
- 이 기술들은 `HTTP/1.1`과 `HTTP/2`의 중간 단계 프로토콜인 `SPDY`에서 시작됨.
- `Google`이 본격 참여해 개발한 `SPDY`는 최대 55% 빠른 웹을 만들 수 있었고, `HTTP Working Group`은 `SPDY`를 통해 프로토콜 최적화를 테스트한 후 몇 가지 보안성을 보완해 `HTTP/2`를 제안.

### `HTTP/2`의 이진 프레임

- `HTTP/2` 이전 버전에서 `HTTP`의 요청과 응답은 메세지(message)라는 단위로 구성.

  - `HTTP` 메세지는 상태 라인(state line), 헤더와 페이로드로 이루어져 요청과 응답에 필요한 정보를 담음.

    - `curl` 명령을 이용해 `HTTP/1.1`로 특정 사이트에 접속하면 `HTTP/1.1` 기반의 메세지 구성 확인 가능.

      ```shell
      $ curl -s -v www.example.com

      > GET / HTTP/1.1
      > Host: www.example.com
      > User-Agent: curl/7.67.0
      > Accept: */*
      ...(중략)
      < HTTP/1.1 200 OK
      < Date: Wed, 08 Jan 2020 11:17:38 GMT
      < Expires: -1
      < Cache-Control: private, max-age=0
      < Content-Type: text/html; charset=ISO-8859-1
      < Server: gws
      ...(중략)
      < Accept-Ranges: none
      < Vary: Accept-Encoding
      < Trasnfer-Encoding: chunked

      <html>
        (중략)
      </html>
      ```

    - 응답에 사용된 `HTTP` 버전 및 `RFC`에 정의된 응답 코드(status code), 응답 내용에 대한 정보가 담긴 헤더, `HTML`이 있는 페이로드로 구성.

- `HTTP/2`에는 기존 `HTTP/1.1` 버전의 메세지 단위 외에도 프레임(frame), 스트림(stream)이라는 단위가 추가.
  - 프레임: `HTTP/2` 통신상 제일 작은 정보 단위이며 헤더나 데이터 중 하나.
  - 메세지: `HTTP/1.1`와 마찬가지로 요청 혹은 응답 단위이며 다수의 프레임으로 이루어짐.
  - 스트림: 클라이언트와 서버 사이 맺어진 연결을 통해 양방향으로 주고받는 하나 혹은 복수의 메세지.
- 여러 개의 프레임 => 메세지 -> 여러 개의 메세지 => 스트림
- 스트림이라는 단위를 통해 요청과 응답이 하나로 묶일 수 있는 구조가 만들어짐.
- 스트림에는 고유 번호가 있는데 하나의 요청이 스트림으로 보내지면 그 응답은 요청 스트림과 같은 스트림 번호를 가짐.
  - 클라이언트는 응답 스트림의 번호를 통해 어떤 요청에 대한 응답인지 구분.
- 큰 데이터는 여러 프레임에 나누어 전달할 수 있고 응답 역시 여러 개의 프레임으로 나누어 전달.
  - 멀티플렉싱이 적용되어 순서에 상관없이 클라이언트에 전달.
- `HTTP/1.1`에서 요청과 응답은 하나의 메세지가 각 오브젝트의 요청과 응답을 담당.
- `HTTP/2`에서는 하나의 스트림이 다수의 요청을 포함하고 이에 대한 다수의 응답 정보를 포함하는 구조로 변경.
  - 스트림 방식을 사용함으로써 `HTTP/1.1` 버전보다 동시 요청 및 응답할 수 있는 오브젝트의 개수가 많아짐.
    > 스트림이라는 단어는 이제 멀티미디어뿐만 아니라 웹 상에서도 콘텐츠를 연속적으로 주고받음으로써 더 유연한 요청과 응답 구조를 가짐.
- 스트림의 유연한 구조 덕분에 서버에서 만들어지는 응답 프레임들이 요청 순서에 상관없이 만들어진 순서대로 클라이언트에게 전달 가능.
- 즉, `HTTP/2`에서는 하나의 `TCP` 연결을 통해 다수의 클라이언트 요청과 서버의 응답이 비동기 방식으로 이루어지는 멀티플렉싱이 사용.
  > 이를 통해 `HTTP/1.1`의 `HOL` 문제가 자연스레 해결.

> `HTTP/2` 프로토콜로 업그레이드하면 특별히 프론트엔드 최적화를 진행하지 않아도 로딩 속도가 빨라질 수 있음.

### 멀티플렉싱

- 멀티플렉싱(multiplexing): `HTTP/1.1`의 파이프라이닝 기능을 개선한 것으로, 하나의 `TCP` 연결 상에서 다수의 클라이언트 요청과 서버의 응답이 비동기 방식으로 이루어지는 기술.
  - 파이프라이닝은 요청과 응답을 반복하는 `HTTP`를 개선해 먼저 요청한 콘텐츠 전달이 완료되지 않아도 다음 콘텐츠르 미리 처리하면서 웹 성능을 더욱 빠르게 만들기 위해 개발된 기능.
    - 여전히 선입 선출 방식을 많이 사용함. 즉, 먼저 요청된 콘텐츠가 완전히 전달되어 완료될 때까지 다음 콘텐츠들은 대기 상태.
  - `HTTP/2`의 스트림이 가진 유연한 구조 덕분에 서버에서 만들어진 응답 프레임들은 요청 순서에 상관없이 만들어진 순서대로 클라이언트에 전달 가능했기 때문에 멀티플렉싱 기술이 가능.
- 멀티플렉싱은 스트림을 사용하여 웹 서버에서 나중에 요청받았더라도, 전달할 수 있는 경우 클라이언트에게 먼저 전달하는 구조.
  - 크기가 크거나 처리가 오래 걸리는 콘텐츠를 전달할 때 발생하는 병목 현상 회피 가능.

### 헤더 압축

- `HTTP/1.1` 버전까지 `Content-Encoding` 헤더를 통해 결정된 알고리즘을 사용하여 `HTTP` 페이로드를 서버에서 압축.
  - 클라이언트는 실제 페이로드보다 작은 크기로 압축된 파일을 내려받을 수 있었지만, 헤더는 압축 없이 원래 크기 그대로 전달받는 문제점.
  - 헤더는 결국 클라이언트와 서버가 자신의 정보를 주고받는 값인데 모든 웹 콘텐츠를 요청하고 받을 때마다 같은 정보 값들을 의미 없이 반복해서 주고받는 구조적인 문제점.
- `HTTP/2`는 클라이언트와 서버 사이에 가상 테이블을 만들어서 동일하고 중복되는 헤더 값들을 테이블에 저장하고 참고하는 방식을 사용해 중복 전달 제거.
- 가상 테이블의 구분
  - 정적 테이블: 미리 정의된 자주 사용되는 헤더 필드를 저장.
  - 동적 테이블: 클라이언트와 서버가 통신하며 주고받는 값들을 업데이트.
- 각 테이블에는 숫자로 표기된 인덱스 번호가 있는데, 동일한 값을 전달할 때는 중복 값을 보내는 대신, 그 값을 가진 인덱스 번호로 대체하여 보냄.
- 헤더 압축 알고리즈임 `HPACK`을 사용해 허프만 알고리즘(Huffman algorithm) 방식으로 헤더를 압축하여 좀 더 경량의 데이터를 주고받기 가능.
  - 허프만 알고리즘: 자주 등장하는 값과 그렇지 않은 값마다 코드 값을 다르게 부여하는 알고리즘.

### 서버 푸시

- 서버 푸시: 클라이언트의 요청이 없어도 서버가 알아서 응답을 보내는 기능.
  - 클라이언트가 특정 콘텐츠를 요청하면 서버는 이후 추가될 요청을 미리 예상하고 요청 없이도 응답.
- 요청과 응답을 반복하고 요청 없이 응답하지 않던 기존 `HTTP` 프로토콜에 큰 혁신.
- 서버 푸시 대상은 웹 서버 관리자나 개발자가 미리 지정 가능.
  - 일반적으로 `HTML`을 호출한 후 해당 페이지가 호출하는 `CSS` 파일이나 `JavaScript`, 이미지 파일 대상이 고정되어 있다면 `HTTP/2`를 지원하는 웹 서버에 서버 푸시 대상으로 미리 설정 가능.
  - 최근의 `ARM`(Application Performance Management) 솔루션들은 서버 푸시 대상을 자동으로 설정해주는 기능을 포함.
- 웹 페이지의 구조와 호출하는 후속 파일의 대상이 변경되어도 이를 자동으로 탐지하고 적용하는 기능 포함.

---

## `HTTP/3`의 최적화 기술

- `RFC`의 `draft 17` 이전 버전인 `HyperText Transfer Protocol over QUIC`의 내용을 바탕으로 하여 `draft 18` 버전부터 공식 용어로 사용 중.
- `QUIC`는 `Google`이 개발한, `OSI` 레이어 중 네 번째 계층에 해당하는 전달 계층 프로토콜.

### `QUIC`

- `QUIC`는 짐 로스킨드(Jim Roskind)를 주축으로 한 `Google` 팀에서 공식 발표한 프로토콜.
- 초창기 `QUIC`는 Quick UDP Internet Connections를 의미하였으며, `UDP`를 채택해 `TCP` 성능을 개선하려는 기술.
- 전달 속도 향상과 덥불어 클라이언트언 서버의 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는 것이 주요 특징.
- `Zero RTT`: `QUIC`에서 실험 단계인, 이전에 클라이언트가 한 번이라도 접속했던 서버라면, 별도의 정보 교환 없이 바로 데이터를 보내느 기술

### `HTTP/3`의 등장 배경

- `TCP`는 오래된 프로토콜로써 성능보다 기능에 초점.
  - 멀티미디어 콘텐츠를 다양한 기기에서 빠르게 전달해야 하는 상황에서 `TCP`의 한계를 극복하고 최적화하는 것이 많은 기업들의 도전 과제.
    - 이진 형태의 `HTTP/2` 프로토콜이 선보인 `HPACK`, 서버 푸시 등은 어느 정도 성공을 거두었고, 프레임을 사용한 멀티플렉싱싱 `HOL` 문제를 해결했으나, `TCP` 스택을 사용하였으므로 `TCP` 프로토콜 자체의 `HOL`을 완벽하게 해결하지는 못함.
- `HTTP/3`는 `HTTP` 내에 `QUIC`를 구현한 최신 버전.
- `HTTP/2`는 `HTTP/1.1`의 단점을 보완하고 새 기능을 추가해 웹 성능을 이끌어내는 전략.
- `HTTP/3`는 새로운 기능을 추가하기보다 `QUIC`이라는 `UDP` 기반의 프로토콜을 사용해 `TCP`가 가지고 있는 `HTTP/2`의 단점을 보완하는 데 중점.

### `HTTP/3`의 특징

- `TCP/IP` 기반 애플리케이션 레이어 프로토콜인 `HTTP`를 `QUIC` 위로 위치시킴.
  - `HQ`(`HTTP` over `QUIC`)라고 부름.
- `HTTP/2` 기술은 큰 변화 없이 `HTTP/3`에 이어졌고, `HQframe`, `QPACK` 등으로 변경.
- `HTTP/2`의 모든 기능을 계승해 `UDP`의 빠른 성능, `QUIC`의 효율성, `TLS 1.3`의 보안성까지 모든 장점을 가짐.

### `HTTP/3`를 지원하는 제품군

- `HTTP/3`을 사용하려면 `HTTP/2`와 마찬가지로 웹 브라우저와 웹 서버. 즉, 클라이언트와 서버 모두 `HTTP/3`를 지원해야 함.
  - `LiteSpeed`: 처음으로 `HTTP/3` `RFC` 내용에 따라 서버를 구현.
  - `Facebook`: 클라이언트가 `HTTP/3`를 지원하도록 업데이트.
    - `HTTP` 서버 구현체의 라이브러리인 `Facebook`의 `proxygen` 프로젝트는 `SPDY`, `HTTP/2`뿐만 아니라 `HTTP/3`까지 지원하도록 업데이트
    - `mvfst` 라이브러리는 `IEFT QUIC`를 구현.
  - `Microsoft`: `Edge` 브라우저도 `HTTP/3`를 지원.
  - `curl`: 적용 완료.
  - `Cloudflare`, `Google`: `CDN`의 상품에서 `HTTP/3`을 적용 가능한 옵션 발표.
    - `Chrome` 브라우저 카나리아 버전에 `HTTP/3`를 적용하기 위해 공동으로 개발 및 테스트.
  - `Nginx`: `HTTP/3` 구현체 발표 및 `Firefox`와 `Chrome` 브라우저의 지원 시작.

### 새로운 프로토콜 적용 시 고려할 점

- 새로운 `IT` 기술을 먼저 적용할 경우 대두되는 사안은 보안 취약점과 사례의 부족.
  - 기존에도 `Netflix`와 `Google` 엔지니어가 `HTTP/2`의 여러 보안 취약점을 발견해 모든 업체가 이에 대한 보안 패치를 진행한 사례가 있음.
- 또한, 이미 `HTTP/1.1`이나 `HTTP/2` 기반 프론트엔드 최적화를 적용한 기업은 최적화 방안을 수정해야 함.
  - `Ex)` 브라우저의 병렬 다운로드를 통해 리소스를 빠르게 받아오는 도메인 분할 기법을 적용했다면 `HTTP/2`나 `HTTP/3`를 사용했을 때 오히려 성능이 반감될 가능성.
  - `EX)` 브라우저의 프리페치 기능을 적용한 경우에는 이를 서버 푸시 기능으로 변경해야 할지 기술적으로 판단하고 충분한 성능 비교 테스트 진행.
- 시장의 레퍼런스가 부족함. `QUIC`와 `HTTP/3`는 `Google` 서비스에 한정되어 있고, `W3Techs`의 조사 결과에 따르면 `HTTP/3`을 사용하는 서비스는 7.3%, 여전히 `HTTP/1.1`을 사용하는 서비스들도 상당히 많음.
  - `HTTP/3`은 웹 서비스에 `UDP`를 사용하므로 얼마나 많은 기업과 공공 기관, 통신사들이 특정 프로토콜을 내부 네트워크에 지원할지, 그리고 이에 맞는 보안 설정을 빠르게 적용할지 미지수.

> `HTTP/3`이 발표된 지 얼마 되지 않아 현재는 과도기.  
> 다양한 레퍼런스와 오픈 소스가 진행됨에 따라 앞으로 `HTTP/3`이 더욱 활성화될 것.
