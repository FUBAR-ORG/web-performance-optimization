# 웹 사이트의 성능을 개선하는 기본적인 방법

## `HTTP` 요청 수 줄이기

- 브라우저의 개발자 도구를 사용하면 웹 페이지가 어떤 콘텐츠를 얼마나 많이 가지고 있는지 쉽게 알 수 있음.
- 웹 페이지에서 요청하는 컨텐츠의 수가 많을수록 로딩 완료 시간은 길어짐.
  - 이미지 같은 콘텐츠가 적은 페이지는 빠르게 로딩 완료.

> 웹 성능을 빠르게 하기 위해서 `HTTP` 요청 수를 줄여야 함.

> 웹 환경에서 클라이언트가 특정 웹 페이지 접속을 요청하며 웹 서버와 어떤 방식으로 통신하는지 알면 이를 이해하기 쉬움.

- 브라우저는 `DNS` 시스템으로 특정 도메인의 접속 `IP`를 알아내 접속을 하고, `HTML` 파일을 먼저 응답 받은 후 `HTML` 내에 있는 `JavaScript`나 `CSS`, 이미지 등의 콘텐츠를 차례로 호출.
  - 브라우저가 `HTML`을 모두 해석하여 콘텐츠를 전부 받아오기까지 호출이 계속 진행되는 것.
- `HTML`을 받아온 도메인과 콘텐츠의 주소가 다르면 `DNS` 조회부터 다시 수행.

> 웹 페이지를 단순하게 제작하는 것이 `HTTP` 프로토콜 요청 수를 줄이는 가장 쉬운 방법이지만, 현실적으로 적절한 방법은 아니므로 페이지에 나타나는 콘텐츠는 동일하게 유지하며 `HTTP` 요청 수를 줄이는 방법을 찾아야 함.

### 스크립트 파일 병합

- 모듈화(`modulation`): 소프트웨어 공학에서 제안한 소프트웨어 개발의 손쉬운 분업화 및 편리한 유지 보수를 위해 최소 기능 단위 별로 소프트웨어 모듈을 나누어 개발하는 것.
- 웹 서비스에서도 웹 사이트의 기능에 해당하는 `JavaScript`, `CSS` 파일들을 기능 별로 분리하여 각각의 파일로 저장하고 호출하는 방식 사용.
- 소프트웨어 공학에서 제안하는 분할 정복(devide & conquer) 모듈화는 `HTTP` 요청 수를 증가시키므로 웹 성능 저하 유발.

> 기능 단위로 모듈화된 여러 파일들을 하나로 합치고 이 하나의 파일을 브라우저가 실행하는 파일 병합으로 `HTTP` 요청 수를 줄일 수 있음.

- 합쳐진 파일의 너무 크다면 그 파일을 다운로드해 브라우저 화면에 나타내는 로딩 과정이 너무 길어질 수 있으므로 적절한 크기를 유지.
- `JavaScript`, `CSS` 같은 텍스트 기반 파일 개수를 쉽게 줄일 수 있음.

### 인라인 이미지

- 인라인 이미지(inline image): `CSS` 안에 해시 정보를 통해 웹 페이지 배경 이미지 파일을 삽입하게 되면 `CSS` 파일의 바이트 크기가 소폭 커지게 되지만, 이미지 파일을 따로 호출하여 해당 크기만큼 파일을 받아오는 전통적인 방식과 비교하면 전체 로딩 시간 단축시키는 방법.
- 인라인 방식으로 웹 페이지 안에 이미지를 포함하는 경우 별도의 이미지 파일이 존재하지 않아 캐시할 수 없으며, `HTML`이 캐시되어야 동시에 캐시 가능.
  - 전반적인 성능 개선 여부를 확인하고 선택 사용해야 함.
- 파일을 병합하는 방법은 `HTTP` 요청 수를 줄이는 효과 외에도 인터넷 상 프록시나 브라우저에 캐시될 확률을 조금 더 높임.
- 웹 서버에서 아무리 빨리 응답을 준다 해도 사용자 위치의 캐시 서버나 클라이언트 기기에 캐시된 콘텐츠를 사용하는 것이 성능 면에서 훨씬 이득.
  - 개발자 도구를 통해 브라우저에 캐시된 콘텐츠의 로딩 속도를 확인하면 매우 짧음.

### `CSS` 스프라이트

- `CSS` 스프라이트(`CSS sprite`): 여러 개의 이미지를 하나의 이미지 파일로 결합해 필요한 이미지가 위치하는 픽셀 좌표 정보를 이용하는 방식.
- 아이콘이나 버튼 등 작은 이미지를 사용할 때 유용.
- `HTML`에 필요한 이미지 영역을 이미지 맵 좌표로 표시.
- 아이콘 및 이미지를 각각 저장하고 호출하면 그만큼의 응답과 요청이 추가되지만, 하나의 이미지를 사용하는 `CSS` 스프라이트는 한 번의 요청으로 처리 가능.

---

## 콘텐츠 파일 크기 줄이기

- 웹 사이트의 파일 수를 줄이더라도 파일 자체의 크기가 크다면 웹 성능 저하 초래.
  - 인터넷 전송 시간이 길어지기 때문.

### 스크립트 파일 압축 전달

- `HTML`, `JavaScript`, `CSS`, `XML`, `JSON` 타입 파일 등은 모두 스크립트(`script`) 형태의 텍스트(`text`) 파일.
- 웹 서버는 각 웹 서버가 지원하는 방식으로 스크립트 형태 콘텐츠를 압축해 클라이언트에게 더 작은 크기로 내려주고, 이를 다운로드한 클라이언트가 압축을 해제하여 사용하는 방식으로 속도 개선 가능.
  - 문서 파일 등을 상대방에게 이메일로 전송하기 위해 `.zip` 파일로 압축하는 것과 비슷.
- 다만, 웹 서버와 클라이언트는 서로가 지원하는 다양한 압축 방식 중 어떤 것을 사용할지 골라 사용해야 함.
  - 지원하지 않는 압축 방식을 사용하면 해제할 수 없기 때문.
- `HTTP` 프로토콜은 `Accept-Encoding`, `Content-Encoding` 헤더를 사용해 압축 방식의 정보 교환을 지원.
  - 클라이언트는 웹 서버에 콘텐츠를 요청하면서 자신이 지원하는 압축 알고리즘을 `HTTP` 요청 헤더에 나열하여 알려 줌.
  - 웹 서버는 나열된 방식 중 자신이 지원하는 압축 알고리즘을 하나 선택해 `HTTP` 응답 헤더로 클라이어느에게 알려줌으로써 클라이언트가 해당 방식으로 압축 콘텐츠를 해제할 수 있게 함.
    ```shell
    // 클라이언트의 요청 헤더 - 브라우저가 지원하는 압축 방식
    Accept-Encoding: gzip, deflate, sdch
    // 웹 서버의 응답 헤더 - `gzip`을 사용할 것을 명시.
    Content-Encoding: gzip
    ```
  - 각 압축 방식의 설명
    - `gzip`: `UNIX` 운영체제에서 일반적으로 사용하는 `LZ77` 파일 압축 라이브러리를 사용. 32비트 `CRC`로 정상 압축 여부 검사.
    - `deflate`: `zlib`라는 파일 압축 라이브러리 사용. `RFC 1951`에 정의된 압축 방식.
    - `sdch`(Shared Dictionary Compression over HTTP): 구글이 개발한 `HTTP` 압축 방식이며 주로 크롬 브라우저에서 사용.

### 스크립트 파일 최소화

- 스크립트 파일 최소화 기법: `HTML`, `JavaScript`, `CSS`와 같이 코딩된 스크립트 파일에 포함된 주석문, 공백, 개행 문자(`new line`) 등 실제 로직에 아무런 영향을 주지 않는 부분을 제거하여 전반적인 파일 크기를 줄이는 방식.
  - 주석문과 적절한 공백, 개행 문자는 가독성을 높여 업데이트나 디버깅이 쉽도록하는 개발자를 돕는 형태.
  - 더이상 업데이트하거나 손대지 않거나 예상했을 때, [`Minify`](https://www.minifier.org/) 사이트에서 스크립트 파일 최소화 테스트 가능.
- 스크립트의 문법을 변경하지 않았으므로 브라우저에서 정상 작동.
- 해당 사이트의 로직을 변경해야 하거나 기존에 발견하지 못했던 버그를 디버깅하는 등 개발자의 작업이 필요한 경우 힘들 수 있음.
- 따라서 개발 서버와 운영 서버를 분리하는 방법 사용.
  - 개발자들은 개발 서버에서 스크립트 원본 파일을 두고 개발, 로직 테스트와 검증 작업.
  - 검증 작업이 완료되면 스크립트를 최소화해 운영 서버로 이관하여 사용.

> 위 두 가지 방식(스크립트 파일 압축, 스크립트 파일 최소화)를 모두 사용하는 것이 효율 좋은 방법.

### 이미지 파일 압축

- 이미지 파일으 웹 사이트에서 가장 많은 용량을 차지하는 콘텐츠.
  - 화려한 사이트에는 고화질 이미지를 많이 사용하기 때문.
- 이미지 파일은 해당 파일 정보를 메타 데이터(meta data)에 포함해 저장.
  - 어떤 카메라, 해상도 등의 정보.
- 메타 데이터는 사람의 눈에 실제 이미지로써 보이지 않으므로 불필요한 부분을 제거하면 크기를 줄일 수 있음.
- [`tiny png`](https://tinypng.com/)의 온라인 서비스를 이용하면 손실 압축 방식으로 이미지를 압축할 수 있음.
  - 별다른 특징이 없는 배경(동일한 색상의 영역이 큰)은 압축률이 높음.

### 브라우저가 선호하는 이미지 포맷 사용

- 웹 상의 이미지는 `JPG`, `GIF`, `PNG`, `BMP` 등 다양한 포맷 사용.
- 각각 회사가 개발한 압축 방식은 자사의 브라우저를 우선 지원.
- 따라서 웹 서버는 동일한 이미지를 각 형식으로 두 장씩 준비해 브라우저 별 다른 포맷으로 내려주는 방싱글 사용할 수 있음.
  - `JPEG` 원본 이미지만 저장하고 있다가 요청한 사용자의 브라우저에 맞게 순식간에 변환하여 내려주는 방식도 사용.

#### `WebP`

- 구글에서 개발하여 크롬 브라우저와 안드로이드 계열에 적용된 손실 압축 방식의 이미지 형식.
- 웹에서 이미지 전달 용도로 많이 사용되는 `JPEG` 이미지 형식을 대체하기 위해 처음부터 웹 사이트 트래픽 감소, 로딩 속도 단축을 목적으로 개발.
- 주로 사진 이미지의 압축 효과가 높고 화질 저하를 최소화하면서도 파일 크기를 작게 만듬.
  - 동일 품질의 `JPEG` 파일보다 `10%` ~ `80%` 압축할 수 있으며, 평균 `50%` 정도 압축.

#### `JPEG XR`

- 마이크로소프트가 `JPEG` 형식에 장점을 추가해 손실 압축과 비손실 압축을 모두 지원하는 이미지 압축 형식.
  - 인터넷 익스플로러, 엣지와 Adobe 사의 이미지 제작 툴이 이 형식을 지원하는 대표적인 소프트웨어.
- 웹에서는 평균적으로 동일 품질 `JPEG`의 `30%` 정도 압축.

### 큰 파일은 작게 나누어 전송

- 용량이 큰 동영상 파일은 인터넷이 느린 곳에서 버퍼링이 발생.
- 앞 혹은 중간 등 흥미 있는 부분부터 보는 사용자도 있으므로, 모든 파일을 다운로드 하는 방식은 버퍼링을 유발하며 실제 보지 않는 부분까지 다운로드함으로써 인터넷 자원 낭비 발생.
- 이러한 경우를 대비해 큰 파일의 일부분을 순서대로 다운로드 하는 부분 요청 응답 방식을 사용 가능.
  - 동영상, 고화질 이미지, 매우 긴 문서 형태의 파일, 게임 패치 파일 등의 대용량 파일 전송에 사용.
  - 웹 서버가 실시간으로 생성 및 갱신하기 때문에 크기를 가늠할 수 없는 콘텐츠를 전송할 때도 유용하게 사용.
- 부분 요청 응답 방식은 웹 서버에 특정 부분 파일 전달을 지원하는 기능이 있을 ㄹ때만 사용 가능.

  - 시뮬레이션

    ```shell
    // 웹 서버의 부분 응답 지원 여부 확인
    curl -I http://www.example.com/bigfile.jpg

    HTTP/1.1 200 OK
    ...
    Accept-Ranges: bytes
    Content-Length: 50000000
    ```

  - 웹 서버가 포함한 정보
    - `Accept-Ranges`: `bytes`
      - `byte` 단위로 파일의 부분(`Ranges`) 지원 기능을 수락(`Accept`)한다는 의미.
    - `Content-Length`: `50000000`
      - 해당 파일의 전체 크기가 `50MB`라는 정보를 클라이언트에게 알려줌.
  - 웹 서버가 부분 파일 지원 기능을 명시하면 클라이언트는 특정 부분만 요청할 수 있음.

    ```shell
    // 파일의 특정 부분 요청하기
    curl -v http://www.example.com/bigfile.jpg -H "Range: bytes=0-1023"

    // 웹 서버의 206 응답
    HTTP/1.1 206 Partial Content
    Content-Range: bytes 0-1023/50000000
    Content-Length: 1024
    ...
    ```

  - 웹 서버가 포함한 정보
    - `Content-Range`: `bytes`: `0-1023/50000000`
      - 전체 파일 범위 중 처음부터 `1,023` 바이트까지만 전달한다는 의미.
    - `Content-Length`: `1024`
      - 현재 전달한 부분의 파일의 전체 용량이 시작 위치와 끝 위치를 알려주는 데이터를 포함하여 `1,024` 바이트임을 명시.
  - 긴 영상을 재생할 때 동영상 플레이어에 보이는 조정 바(`progress bar`) 구현을 위해 이 값을 사용함.

- 클라이언트는 구간별로 부분 파일 요청을 반복하여 콘텐츠가 끈김 없이 서비스될 수 있도록 구현.
- `Content-Length`에서 전달한 파일이 실제 요청한 `0~1,203` 바이트보다 `1`바이트 큰 것은 부분 파일의 마지막임을 알려주는 지시자가 포함되어 있기 때문.
  ```shell
  // 여러 범위를 가진 부분 파일 요청
  curl -v http://www.example.com/bigfile.jpg -H "Range: bytes=0-50, 100-150"
  ```
  - 부분 파일을 요청할 때 여러 범위의 파일을 쉼표(`,`)를 사용해 동시 요청을 할 수 있음.
  - 특정 부분의 영상을 재생하면서 뒷부분 영상을 살짝 드러내고 싶을 때 유용하게 사용 가능.
- 큰 파일에서 필요한 부분만 요청하고 전달받으면 파일의 다운로드 속도를 빠르게 함.
- 또한, 사용하지 않는 구간의 콘텐츠를 낭비하지 않을 수 있음.

---

## 캐시 최적화하기

### `IT` 분야의 캐시

- 자주 사용되는 콘텐츠나 특정 데이터 등을 임의의 저장소에 복제해두고 재사용하는 방식.
- 시스템이 캐시 저장소에 접근하는 시간이 실제 데이터 위치에 접근하는 시간보다 ㄷ짧고, 시스템의 리소스를 아낄 수 있는 점에 착안해 콘텐츠를 다시 받아오는 시간을 절약하고 싶을 때 사용.

### 컴퓨터 공학 분야의 캐시

- 컴퓨터 자원을 절약하려는 방법에서 시작한, 컴퓨터의 자원을 적게 사용하면서 반복 사용되는 명령에 빠르게 응답하기 위해 만들어진 방식.
  - 대용량 메인 메모리에 빠르게 접근하는 `CPU` 캐시.
  - 자주 사용하는 콘텐츠를 미리 하드 디스크에 저장해두는 디스크 캐시.

### 인터넷 분야의 캐시

- `ISP` 회사가 지역에 분포된 특정 시스템에 사용자와 원격 시슽메 사이에 주고 받은 데이터를 캐시하고 다음 사용자에게 제공하는 방식.
- 콘텐츠를 캐시하는 시스템을 프록시(`Proxy`) 서버라고 부름.
  - 프록시 서버 덕분에 `ISP` 회사들은 대역폭을 아낄 수 있음.
  - 소비자들은 좀 더 빠르게 콘텐츠 응답을 받을 수 있어 만족도가 증가함.
- 인터넷 캐시는 캐시 영역에 미리 데이터를 복사해두는 `PUSH` 방식과 실제 요청이 있을 때만 캐시에 저장하는 `PULL` 방식으로 분류.
  - `PUSH` 방식은 특정 시간, 특정 지역에 사용자의 요청이 과다하게 몰릴 것에 대비.
    - 유입 트래픽을 예상하고 콘텐츠 리스트를 파악해 여러 지역의 프록시 서버에 미리 배포해두면, 사용자는 빠르게 콘텐츠를 다운로드하고 배포사는 원본 서버의 [`peak`](https://www.abbreviationfinder.org/ko/acronyms/ptl_peak-traffic-load.html) 트래픽 접속을 방지하는 등 서버에 트래픽이 몰릴 때 발생하는 기술적 문제를 예방.
- 인터넷에서 빠른 자원 전달을 위한 인터넷 캐시가 발달하자 해당 콘텐츠를 소모하는 브라우저도 콘텐츠를 캐시하기 시작.
  - 빈번히 접속하는 웹 페이지에서 자주 바뀌지 않는 이미지나 `JavaScript`, `CSS` 파일 등을 인터넷 프록시 서버에도 캐시하지만 사용자의 브라우저도 해당 기기에 캐시.
  - 다음 접속할 때 인터넷에 요청하지 않아도 캐시된 콘텐츠 사용 가능.

### 인터넷 캐시 사용

- 인터넷 상에서 자주 요청되는 콘텐츠를 캐시하는 것은 속도와 인프라 보호 차원에서 중요.
- 주로 프록시 서버(`Proxy Server`)가 이를 담당하며, 인터넷의 수 많은 경로에 거미줄같이 존재.

#### 프록시

- 프록시라는 단어는 본래 대리인을 뜻하며, 인터넷 구간에서 서버 대신에 클라이언트의 자원 요청에 응답해주는 본연의 기능에서 유래됨.
- 콘텐츠 소비자와 제공자 사이의 인터넷 구간이 멀 때 구간의 중간 정도에 하드웨어 또는 소프트웨어 방식으로 프록시를 설치해 사용.
- 서버와 클라이언트 사이에서 통신을 대신하는 기능 자체를 프록시, 그 중계 기능을 수행하는 서버를 프록시 서버라고 함.

#### 프록시 서버

- 프록시 서버는 클라이언트가 처음 요청한 콘텐츠를 원본 서버(`origin server`)에 대신 요청하여 클라이언트에게 이를 전달해주고 이를 스스로 저장.
- 이후 다른 클라이언트가 동일한 콘텐츠를 요청했을 때 원본 서버에 접속할 필요 없이 자체 저장한 콘텐츠를 제공.
- 프록시 서버는 사용자가 많은 지역에 여러 곳을 선택하여 설치.
  - 먼 곳에 있는 원본 서버의 콘텐츠를 캐시를 사용하여 저장하고, 클라이언트가 요청했을 때 서버 대신 응답해주는 방식
- 프록시의 장점
  1. 사용자 부근의 프록시 서버의 응답 속도가 원래 서버의 응답 속도보다 빠름.
  2. 원본 서버로 몰릴 수 있는 인터넷 트래픽을 프록시 서버로 분산해 원본 서버의 자원을 절약.

> 클라이언트와 서버 중간에 위치한 인터넷 상의 캐시.

### 브라우저 캐시 사용

- 특정 웹 사이트에 접속하여 받아온 웹 콘텐츠들 중 브라우저가 저장할 수 있는 콘텐츠들을 클라이언트 측에 저장해 인터넷 상의 요청을 아예 하지 않겠다는 개념.
- 특정 콘텐츠가 브라우저 캐시를 사용할지 아닐지는 일반적으로 웹 서버에서 먼저 결정.
  - 웹 서버 관리자는 해당 콘텐츠의 캐시 정책을 조사하고 이를 웹 서버의 캐시 설정에 충실히 적용.
- 정책 결정 후 `Cache-Control` 응답 헤더를 통해 설정 내용을 클라이언트에게 전달.
- `Cache-Control` 헤더에는 캐시 기간을 초(second)로 표시하여 브라우저에 전달.
  - 이 기간을 캐시가 생존하는 시간(`TTL`, Time To Live)라고 함.
    ```
    // 캐시 TTL의 설정
    Cache-Control: max-age=<캐시를 할 시간(초 단위)>
    ```
- 해당 콘텐츠가 개인 정보 등 민감한 정보를 가지고 있거나 절대 브라우저에 캐시하면 안 되는 콘텐츠라면 캐시하지 않도록 설정.
  ```
  // 캐시하면 안 되는 콘텐츠의 헤더 값
  Cache-Control: no-store
  ```
- 브라우저 캐시를 설정했을 때 브라우저가 원본 서버에 업데이트된 콘텐츠 대신 캐시되었던 예전 콘텐츠를 사용할 수도 있음.
- 따라서 브라우저 캐시를 사용하고 원본 서버의 콘텐츠 여부를 미리 조사해 변경이 없을 때만 캐시된 콘텐츠를 사용하도록 설정.
  ```
  // 원본 서버의 콘텐츠 변경 확인
  Cache-Control: no-cache
  ```
- 브라우저가 캐시 사용 전 웹 서버에 설정한 캐시 가능 주기를 먼저 확인하여 해당 시간 범위 내에서만 캐시를 사용하도록 설정.
  ```
  // 캐시 가능 주기 확인
  Cache-Control: must-revalidate
  ```
- 여러 개의 값 동시에 설정.
  ```
  // 캐시가 절대로 불가능함을 알려주는 헤더 값
  Cache-Control: no-cache, no-store, must-revalidate
  ```
- 해당 콘텐츠를 명확히 캐시할 수 있을 때, `public` 지시자와 `max-age` 지시자 동시 사용 가능.
  ```
  // 캐시할 수 있음을 알려주는 헤더 값
  Cache-Control: public, max-age=31536000
  ```
- `Cache-Control` 헤더의 `max-age` 값은 브라우저가 콘텐츠를 전달받은 후 얼마의 시간 동안 캐시할지 초 단위로 설정하는 방법.
- 특정 날짜의 특정 시간까지 캐시할 수 있는지 일정 자체를 설정하려면 `Expires` 응답 헤더를 사용.
  ```
  // 캐시 가능한 일정을 알려주는 헤더 값
  Expires: <캐시 사용이 가능한 날짜>
  ```

> 클라이언트 위치의 캐시.

---

## `CDN` 사용하기

- `CDN`(Content Delivery Network, 콘텐츠 전송 네트워크): 인터넷 상에서 생산, 소비되는 웹 콘텐츠를 사용자에게 빠르게 전달아기 위해 캐시 서버(`cache server`) 혹은 에지 서버(`edge server`)라 불리는 대용량 인터넷 캐시 영역에 콘텐츠를 저장해 사용하는 네트워크 방식.
- 여러 노드를 가진 네트워크에 콘텐츠를 저장하여 제공하는 프록시의 일종.
  - 오늘날의 인터넷 환경에서 광범위하게 사용되어 전 세계의 인터넷 트래픽 성능을 개선.
- `CDN`은 촘촘히 분산된 서버로 이루어졌으며 사용자의 웹 콘텐츠 요청에 직접 응답.
  - 원본 서버라 불리는 콘텐츠 서버와 사용자(클라이언트) 사이에서 중재자 역할을 수행.
- `CDN`은 주로 실제 인터넷 사용자가 가입한 `ISP`의 데이터 센터 내에 캐시 서버를 두고 이를 직접 사용자와 연결해 데이터를 전송.
- `CDN`의 장점
  1. 인터넷 상 원거리에 있는 콘텐츠를 전달받는 과정에서 클라이언트와 웹 서버 사이에 발생할 수 있는 네트워크 지연(network latency)과 패킷 손실(packet loss) 현상을 줄일 수 있음.
  2. 사용자는 가까운 에지 서버에 캐시된 콘텐츠를 전달받으므로 전송에 필요한 `RTT`(Round Trip Time)가 줄어들어 빠르게 콘텐츠를 받을 수 있음.
  3. `CDN`의 에지 서버가 캐시된 콘텐츠를 전송하므로 원본 서버의 부하를 줄일 수 있음. 또한, 인프라를 확충하는 데 드는 인력과 경비를 줄일 수 있음.
  4. 콘텐츠가 에지 서버와 주변 에지 서버 사이에 `ICP`(Internet Cache Protocol)를 이용한 서버 전파를 할 수 있어 캐시 콘텐츠의 재사용률이 매우 높음.
  5. `CDN` 사업자들은 사용자 요청 트래픽이나 기술적 특이 사항을 모니터링하는 시스템을 갖추고 있어 인터넷 전송이 필요한 콘텐츠의 시스템과 인적 관리 비용이 절감.
- 최근 콘텐츠와 시스템이 데이터 센터에서 클라우드로 이동하는 추세.
  - 따라서 인터넷 상에서 콘텐츠를 전달할 때 발생할 수 있는 문제점을 개선하거나 성능을 유지하고 관리해야 하는 새로운 가속화 과제가 등장.
  - 이러한 과제를 해결하려는 `CDN` 기술도 진보.
