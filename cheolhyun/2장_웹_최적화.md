# 웹 최적화

- 최적화(optimization)란, 알맞은 상황으로 맞춘다는 의미이며, 일반적으로 최대 효과를 얻기 위한 최선의 노력을 하는 행위를 말함.
- 같은 비용과 시스템을 사용했더라도 어떻게 설계하고 구현했는지에 따라 성능과 시스템의 신뢰성이 천차만별.
- 하드웨어: 용량 설계 최적화
- 웹 사이트: 검색 엔진 최적화(Search Engine Optimization, `SEO`)
  - 좀 더 빠르게 검색되거나, 다른 사이트에 비해 자주 상단에 노출.
  - 웹 사이트 홍보 또는 수익 창출에 도움이 됨.

## 웹 최적화란

- 최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 다양한 노력.

> 최고의 성능을 만드는 최적화 조건을 갖추는 것.

### 프론트엔드 최적화

> 웹 `UI/UX`와 관련된 최적화.

- `HTML`, `JavaScript`, `CSS`, 이미지, 타사 파일 등이 어우러져 콘텐츠를 만들어낼 때 최적화를 진행.
- 프론트엔드 최적화가 잘 되어 있는 웹 사이트는 브라우저에서 콘텐츠를 다운로드, 로딩, 렌더링할 때 속도가 빠름.
- 웹의 성능은 대부분 프론트엔드에 좌우.
- 프론트엔드 최적화 기술은 웹 브라우저를 실제로 사용하는 사용자 환경에 따라 달라짐.(PC, 태블릿, 모바일 등 사용자 기기, 네트워크 속도와 품질, 브라우저 등)
  - 어떤 경우에 웹 성능이 좋지 않는지를 파악하고 알맞은 조치를 취해야 함.
- 프론트엔드 최적화 대표 기술
  - 스크립트를 병합(merge)하여 브라우저의 호출 개수를 줄임
  - 스크립트 크기를 최소화해 바이트(`byte`) 자체를 줄임
  - 스크립트를 `gzip` 등으로 압축하여 전달
  - `WebP` 등으로 브라우저 이미지 형식을 최적화
  - 이미지 손실, 무손실 압축
  - `Cache-Control` 응답 헤더를 통해 브라우저 캐시를 충실히 사용
  - 도메인 수를 줄여 `DNS` 조회를 최소화
  - `CSS`를 `HTML` 상단에, `JavaScript`를 `HTML` 하단에 위치시킴
  - 페이지 미리 읽어 오기(`page prefetching`)
  - 타사 스크립트가 웹 성능을 방해하지 않도록 조정

### 백엔드 최적화

> 웹 `UI`를 로직에 맞게 만드는 최적화.

- 백엔드: 웹 서버, 웹 애플리케이션 서버, 데이터베이스, 로드 밸런싱, `DNS` 서버 등.
- 프론트엔드 최적화에 비해 가시적인 효과가 크지 않지만, 웹 사이트의 빠른 로딩보다 네트워크를 정상적으로 사용하고 콘텐츠를 전달하기 위해서는 반드시 필요한 요소.
- 백엔드 최적화 대표 기술
  - `DNS` 응답이 빨라지도록 서버 증설
  - `DNS` 응답을 빠르게 할 수 있도록 `DNS` 정보를 최대한 캐싱
  - 웹 서버가 있는 데이터 센터의 네트워크 출력(`throughput`)/대역폭(`bandwidth`) 증설
  - 웹 서버, 웹 애플리케이션 서버의 `CPU`/`RAM` 증설
  - 프록시 서버를 설정하여 웹 콘텐츠를 캐싱
  - `CDN`(Content Delivery Network)을 사용해 인터넷 상에 콘텐츠 캐싱
  - 데이터베이스 정규화로 디스크 `I/O` 최적화
  - 데이터베이스 캐싱으로 응답을 빠르게
  - 로드 밸런싱을 통해 가장 성능이 좋은 웹 서버로 요청을 연결
  - 웹 애플리케이션 로직을 가볍고 빠르게 개발

### 프로토콜 최적화

> 웹 콘텐츠를 더 빠르게 요청하고 응답하도록 프로토콜을 업그레이드 하는 과정.

- 웹 콘텐츠를 전달하는 `HTTP`/`HTTPS` 프로토콜 자체의 효과를 극대화하면 웹 서버가 클라이언트에게 콘텐츠를 최대 속도와 최저 지연 시간으로 전달 가능.

---

## `TCP/IP` 프로토콜

- 웹에서는 `TCP/IP` 프로토콜의 일종인 `HTTP`를 사용해 콘텐츠를 전달.
- `OSI`(Open System Interconnection) 7계층 모델에서 `TCP`는 4번째 전송 계층, `HTTP`는 7번째인 응용 계층에 속함.
- 전송 계층: 네트워크 상에서 송신자와 수신자 사이에 데이터 전송을 보장하는 역할.
- 응용 계층: 실제 네트워크 상에서 소프트웨어와 사용자의 상호 연동을 담당하는 역할.
  - 사용자가 메일을 보냄, `FTP`로 파일을 업로드, 인터넷으로 웹 서핑 등.

> 상위 계층인 응용 계층이 하위 계층인 전송 계층을 바탕으로 운용되는 구조.

- `TCP` 네트워크의 대표적인 성능 지표
  - 대역폭: 특정 시간 동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는지 시간당 전송량.
    - 크기가 큰 이미지 파일을 다운로드 하려면 완료 시간은 클라이언트와 서버 사이 대역폭에 영향.
  - 지연시간: 클라이언트와 서버 간 콘텐츠를 전달하는 물리적인 시간.
    - 클라이언트와 서버 사이 요청, 전달, 응답까지 걸리는 시간.(브라우저 렌더링 단계는 포함하지 않음)
  - `Round Trip Time`(`RTT`): 서버와 클라이언트 두 호스트를 모두 왕복하는 데 걸리는 지연 시간.
    - 인터넷 상에서 게임을 즐기거나 화상 채팅 등을 할 때 품질에 영향을 줌.
    - 스트리밍 서비스는 지연 시간에 따라 전달받는 영상 파일의 품질을 조절하여 버퍼링을 줄일 수 있는 "가변 스트리밍(adaptive streaming)" 방식을 사용.
- `TCP`의 성능이 나빠지면 웹 성능도 영향을 받음.

### `TCP` 혼잡 제어

- `TCP` 혼잡 제어(congestion control): `TCP` 네트워크의 토신량을 조절하여 혼잡해지지 않도록 하는 방식.
- `TCP` 혼잡 붕괴(congestion collapse): `TCP` 네트워크의 통신량이 실제 처리량보다 많아서 문제가 발생하는 것.
  - 인터넷에 연결된 호스트들이 최대한 많은 정보를 전송하려고 많은 네트워크 패킷을 보내기 때문에 발생.
- `TCP` 혼잡 제어 기술은 패킷을 보내는 쪽에서 네트워크에서 수용할 수 있는 양을 파악하고 그만큼의 패킷만 보내는 약속으로 `TCP` 혼잡을 해결.
- 받는 쪽은 패킷이 정상적으로 송신되었음을 알리는 `ACK` 패킷을 보내며, `ACK` 패킷을 받은 호스트는 지속적으로 패킷을 보낼 수 있음.
- 호스트가 네트워크의 상태를 시시각각 파악하고 전송 속도를 조절하는 것 또한 혼잡 제어의 기능.
  - 처음부터 네트워크가 얼마만큼의 패킷을 수용할 수 있는지 정확히 파악하는 것은 어렵고, 변화가 잦기 때문.

#### 느린 시작

- 느린 시작(slow start): `TCP` 연결이 시작되면 전송 가능한 버퍼의 양인 혼잡 윈도우(Congestion Window, `CWND`)의 초깃값을 작게 설정하여 전송.
  - 정상 수신 응답인 `ACK`를 포함한 패킷이 도착할 때마다 더 많은 패킷을 보내고, 이를 패킷 유실(packet drop)이 발생하기 전까지 반복하는 방식.
  - 초기에는 적은 패킷을 보내면서 곱셈 방식으로 전송 패킷의 크기를 빠르게 늘리는 방법.
- 호스트가 `ACK` 응답을 받지 못하면 혼잡 윈도우의 크기는 더이상 늘어나지 않음.
  - 느린 시작 기술을 통해 네트워크가 수용할 수 있는 혼잡 윈도우의 크기를 파악하면 그 이상의 패킷을 보내지 않음.
- `HTTP`에서도 사용되며 웹 사이트에 접속한 브라우저는 처음부터 많은 패킷을 보내지 않음.

#### 빠른 재전송

- 빠른 재전송(fast retransmit): 먼저 도착해야 하는 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 수신자가 일단 `ACK` 패킷을 보내는 방식.
- 중간에 패킷이 하나 손실되면 송신자는 중복된 `ACK` 패킷을 통해 이를 감지하고 정상적으로 전송되지 않은 패킷을 재전송.
- 중복된 패킷을 3개 받으면 반드시 손실된 패킷을 재전송.
- 동시에 혼잡 제어가 필요한 상황임을 인식해 혼잡 윈도우 창 크기를 줄이는 작업도 실행.

#### 흐름 제어

- 흐름 제어(flow control): `TCP` 송신자가 데이터를 너무 빠르게 혹은 너무 많이 전송하여 수신자의 버퍼가 오버플로(`overflow`)되는 현상을 방지하는 기술.
- 수신자는 수신 버퍼(`receive buffer`)를 가지고 있는데, 이로 인해 상위 계층으로 세그먼트를 보내는 애플리케이션 프로세스에서 데이터를 읽는 속도가 느려질 수 있음.
- 따라서 송신자가 데이터를 전송하는 속도를 애플리케이션 프로세스를 읽는 속도와 유사한 수준으로 만들어 트래픽 수신 속도를 송신 속도와 일치시키는 기술.

---

## `HTTP` 프로토콜

- `HTTP` 성능을 개선하면 웹 성능도 향상.

### `HTTP` 최적화 기술

- `HTTP` 프로토콜 업데이트는 주로 웹 환경 변화에 밀접하게 대응하는 기능을 추가한 것.
- `HTTP/0.9` 버전까지 클라이언트와 서버의 인터넷 통신 정상화, 가용성 신뢰성 등에 초점.
- `HTTP/1.0` 버전부터는 클라이언트와 서버 사이 요청과 응답을 빠르게 할 수 있는 연구 진행.
- `HTTP/1.0` 버전까지는 단순 `CS`(Client Server)환경에서 사용할 수 있는 충분한 기능이 포함.
- 웹 환경이 멀티 호스트(multi host) 환경으로 변하면서 `HTTP/1.1` 버전부터는 멀티 호스트 기능과 클라이언트와 서버 사이에서 `TCP/IP` 연결을 재사용하는 기능을 추가.
  - 연결 기반의 `HTTP` 최적화 기술: 연결 재사용(persistent connection), 파이프라이닝(pipelining) 기법.

### `HTTP` 지속적 연결

- `TCP`의 통신을 연결하는 `3-way handshake` 방식은 서버 사이 `SYN`, `SYN-ACK`, `ACK`의 3번의 요청과 응답으로 이루어짐.
  - 이 방식은 송신자와 수신자 사이의 신뢰할 수 있는 안전한 통신을 추구하는 `TCP` 알고리즘에서 시작.
  - 많은 웹 콘텐츠를 전달해야 하는 `HTTP` 통신에서 번거로움.
  - 적은 `HTTP` 요청과 응답을 위해 매번 `TCP` 연결을 맺고 끊는 알고리즘은 웹 로딩 시간에도 영향을 줌.
- 웹 사이트에 이미지 등의 멀티미디어 콘텐츠가 늘어나면서 `TCP` 연결 재사용이 필요하게 되어 등장한 것이 지속적 연결 기술.
- `Keep-Alive` 혹은 연결 재사용이라는 용어로도 불림.
- `HTTP` 지속적 연결은 클라이언트와 서버가 `TCP` 상에서 한 번 연결되면 둘 사이의 연결이 완전하게 끊어지기 전까지 맺어진 연결을 지속적으로 재사용하는 기술.
- `HTTP/1.0` 버전
  - 해당 기능을 지원하는 웹 서버에 `HTTP` 요청 헤더를 이용하여 요청.
  - `Connection` 헤더 및 `keep-alive` 속성을 활용.
    ```
    Connection: keep-alive
    ```
  - 이후 지속적 연결을 지원하는 서버는 클라이언트의 요청을 수용하여 동일한 헤더를 `HTTP` 응답에 포함하는 것이 규약.
- `HTTP/1.1` 버전

  - `Connection` 헤더를 사용하지 않아도 모든 요청과 응답이 `HTTP` 지속적 연결을 기본으로 지원.
    - `HTTP` 응답이 완료되거나 `TCP` 연결을 끝어야 할 때만 `Connection` 헤더 사용.
  - `curl`은 `HTTP` 요청과 응답을 커맨드 라인(command line) 형식으로 실행할 수 있는 애플리케이션.
  - 간단한 `HTTP` 요청이나 웹 서버의 응답을 헤더와 페이로드로 나누어 자세히 살펴볼 때 유용.
  - `curl` 명령문 예제 1

    ```curl
    curl -v -o out https://www.akamai.com/kr/ko

    > GET /kr/ko HTTP/1.1
    > User-Agent: curl/7.37.1
    > Host: www.akamai.com
    > Accept: */*
    >
    < HTTP/1.1 200 OK
    < Last-Modified: Thu, 22 Sep 2016 04:05:47 GMT
    < Content-Type: text/html;charset=utf-8
    < Connection: keep-alive
    ```

    - 클라이언트가 `Connection: keep-alive`를 보내지 않아도 서버가 `HTTP` 지속적 연결 기능을 기본적으로 사용하겠다고 클라이언트에 전달.

  - `curl` 명령문 예제 2

    ```curl
    curl -v -o out https://www.akamai.com/kr/ko -H "Connection: close"

    > GET /kr/ko HTTP/1.1
    > User-Agent: curl/7.37.1
    > Host: www.akamai.com
    > Accept: */*
    >
    < HTTP/1.1 200 OK
    < Last-Modified: Thu, 22 Sep 2016 04:05:47 GMT
    < Content-Type: text/html;charset=utf-8
    < Connection: close
    ```

    - 클라이언트가 지속적 연결을 사용하지 않겠다는 요청으로 `Connection: close`를 포함.
    - 서버는 이를 수락한 메세지를 응답 헤더에 포함.

  - 클라이언트와 서버가 지속적 연결 기능이 필요 없는 경우에만 `close` 요청을 통해 전달.

- 많은 클라이언트가 접속하는 페이지에서는 서버의 성능을 고려해 `HTTP` 지속적 연결 기능을 사용할지 결정.
- 반대로 지속적 `HTTP` 연결을 사용하여 단일 시간 동안 `TCP` 연결의 수를 줄여 서버의 `CPU`나 메모리 자원을 절약하고 네트워크 혼잡이나 지연을 줄이는 장점도 존재.
- 복수 개의 `HTTP` 요청과 응답을 병렬로 동시 처리하기 위한 `HTTP` 파이프라이닝 기술을 사용하기 위해선 필수적으로 지원되어야 함.
- `HTTP/2` 버전은 단일 `TCP` 연결을 통해 클라이언트와 서버 사이 응답을 지연 없이 스트림(`stream`) 형태로 다수의 `HTTP` 요청과 응답을 주고 받을 수 있는 멀티플렉싱(`multiflexing`) 기술을 토대로 만듬.
  - `HTTP/2`를 사용한다면 더이상 지속적 연결을 고민할 필요가 없음.

### `HTTP` 파이프라이닝

- `HTTP` 선입 선출(First In First Out, `FIFO`) 방식의 단점을 극복하는 데서 출발.
- 기존에는 `HTTP` 요청과 응답이 여럿일 때 하나의 응답이 지연되면 나머지 요청과 응답이 모두 지연될 수 밖에 없는 구조.
- `HTTP` 파이프라이닝은 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 수신자 측에 전송하는 기술.
- 중간에서 응답 지연이 발생하더라도 클라이언트는 먼저 서버 측의 응답을 받을 수 있어 전체적으로 빠른 웹 로딩이 구현되는 구조.

---

## `DNS`

- `DNS`(Domain Name System)는 인터넷 호스트 명을 클라이언트와 서버가 이해할 수 있는 `IP` 주소로 변환해주는 시스템.
- `DNS` 질의와 응답 성능이 나쁘면 웹 사이트 로딩에 영향을 줄 수 있음.
- 관리자는 자신이 운영하는 웹 사이트 호스트 명의 `DNS` 질의 속도를 파악하고 이를 개선.

### `DNS`의 작동 원리

- 질의 과정
  1. 로컬 `DNS` 서버로 질의
     - 브라우저는 로컬 `DNS` 서버에 주소창에 입력된 도메인에 대한 1차 질의.
     - 로컬 `DNS`는 사용자와 인접한 `DNS`.
       - 사용자가 PC 등에 수동으로 설정한 `DNS`의 `IP`.
       - PC가 `DHCP` 설정을 통해 사용하는 `ISP` 인근 서버.
     - 이 과정에서 해당 도메인 `IP` 주소가 이전에 질의되었고 그 캐시 주기 값이 남아 있다면 로컬 `DNS`는 자신이 캐싱하고 있는 `IP` 주소 반환.
  2. 루트 `DNS` 서버로 질의
     - 소유하지 않은 도메인 정보에 대한 질의를 받으면 로컬 `DNS`는 전체 도메인을 관장하는 루트 `DNS`에 질의.
     - 이 정보가 없는 루트 `DNS`는 가지고 있는 `.com` 도메인 서버의 `IP` 주소를 알려줌.
  3. `.com DNS` 서버로 질의
     - 로컬 `DNS`는 `.com` 도메인을 관장하는 `.com DNS`에 질의.
     - 이 정보가 없는 `.com DNS`는 자신이 알고 있는 `example.com` 네임 서버의 `IP` 주소를 알려줌.
  4. `example.com DNS` 서버로 질의
     - 로컬 `DNS`는 `www.example.com` 도메인을 관장하는 `example.com DNS`에 질의.
     - `example DNS`는 자신이 알고 있는 `www.example.com` 네임 서버의 `IP` 정보를 알려줌.
- 도메인을 `IP` 주소로 질의하여 값을 받아오는 과정에는 하나의 `DNS` 서버가 아닌, 도메인 구조 계층에 따라 각각의 `DNS` 서버들이 관여.
- 이렇게 계층형으로 나누어진 역할에 따라 순차적인 `DNS` 질의를 반복하여 값을 받아오는 프로세스 과정을 "반복적 질의(iterative query)"라고 함.
- `DNS` 서버들의 속도가 느리거나 제때 응답을 주지 못하면 웹 성능에 영향을 미침.
- 로컬 `DNS` 서버는 사용자가 이용 중인 `ISP` 업체나 `DNS` 전문 서비스 업체 등이 관리.
- 루트 `DNS` 서버는 `ICANN`(Internet Corporation for Assigned names and Number) 기관에서 관리.

> 웹 서비스 운영 업체는 `example.com` 서버부터 관여해 `DNS` 전문 업체의 서비스를 받거나 분산된 `DNS` 서버를 직접 운영하는 방식으로 `DNS` 성능을 향상시킬 수 있음.

### 사용 중인 다양한 도메인 확인 방법

- 웹 사이트는 자신의 웹 콘텐츠 뿐만 아니라 다른 웹 서비스의 다양한 콘텐츠를 호출하여 사용.
  - 오픈 소스(open source) 이용이 활성화되면서 더욱 커짐.
- `JavaScript` 로직 모듈, 무료 폰트, `CSS` 파일, 타사 스크립트 서비스들이 모두 포함.
- `Chrome Browser`에서 `[도구 더보기] -> [개발자 도구] -> [Source]` 항목을 통해 하나의 웹 페이지에서 어떤 도메인들이 사용되고 있는지 쉽게 파악 가능.
- 다양한 서비스들이 각 공급자 도메인을 사용하므로 자신의 웹 서비스 도메인 성능이 빠르다고 해서 웹 성능에 문제가 없다고 판단하기 어려움.
- 특정 업체의 서비스에서 문제가 발생하지 않도록 지속적으로 모니터링하고 해결해야 함.
  - 특정 모듈 서비스 업체의 `DNS` 조회가 불가능하거나 느리다면 해당 모듈을 다운로드해 자신의 웹 서버에 업로드 후 설치하여 사용하는 방법 등.
- `DNS` 질의 도메인 수가 줄어들 수록 `DNS` 응답 속도를 빠르게 할 수 있음.

### 웹 성능을 최적화하는 도메인 운용 방법

- 직접 개발한 내부 서비스에 도메인 분할을 하고 싶다면 상위 도메인(top level domain)을 동일하게 해 `DNS` 질의를 최대한 적게 만드는 것을 권장.
- 공통된 상위 도메인을 사용하는 서비스들은 도메인 질의를 담당하는 네임 서버에 캐싱된 정보를 재사용할 수 있어 `DNS` 질의 시간을 단축.
- `HTTPS` 사용을 위한 `SSL` 인증서를 와일드카드 형식으로 하나만 생성해도 모든 도메인에 사용 가능.
- `HTML`에 `DNS` 프리페치(`prefetch`) 기능을 사용하면 웹 페이지에 사용된 도메인들의 `DNS`를 조회하는 시간이 좀 더 빨라짐.

  - `DNS` 프리페치: 하나의 웹 페이지에 다수의 도메인 호스트 명이 섞여 있을 때 웹 문서 페이지를 여는 시점에 멀티 스레드 방식으로 미리 `DNS`를 조회해 빠르게 `IP` 주소를 불러오는 기술.

    ```html
    <link rel="dns-prefetch" href="//img.feokorea.com" />
    <link rel="dns-prefetch" href="//script.feokorea.com" />
    <link rel="dns-prefetch" href="//api.feokorea.com" />
    ```

  - 위와 같이 `<link>` 태그 지시자 구문에 `dns-prefetch`라는 명령어를 사용해 페이지 상단에서 미리 `DNS`를 조회하면 성능이 좋아짐.
  - 최근 사용되는 많은 브라우저가 `dns-prefetch` 명령에 관한 `HTML` 구문을 지원.

---

## 브라우저

- `HTTP`, `DNS`를 사용해 사용자가 원하는 `HTML`, 이미지, 오디오, 동영상 등의 웹 콘텐츠를 전달하는 소프트웨어.

### 브라우저의 역사와 특징

- 1990년대 초반의 브라우저는 `HTTP`와 `DNS`를 접목해 웹 서버에 접속해 콘텐츠를 가져오는 단순한 기능 수행.
  - 넷스케이프(`Netscape`)
- 그 후 `CSS`와 오디오 파일 재생 기능 추가
  - 화려하고 생동감 있는 콘텐츠를 지원.
  - `MS`의 `Internet Explorer 3`
- 비디오 형태의 멀티미디어 요소가 늘어나면서 `HTML5`와 `CSS3.0` 버전 개발.
- `HTML`, `CSS`, `AJAX` 등 최신 기술 추가.
- `HTTP`가 빠르게 웹 콘텐츠를 전달해도 브라우저가 빠르게 동작하지 않으면 전반적인 웹 성능은 느림.
- 따라서 웹 성능을 최종 테스트하거나 디버깅하는 작업은 대체로 브라우저를 통해 수행.

### 내비게이션 타이밍 `API`

- 내비게이션 타이밍 `API`(Navigation Timing API): 웹 사이트의 성능을 측정하는 데 사용할 수 있는 데이터 제공.
- 웹 페이지가 열리는 식간과 로딩이 완료되는 시간 차이를 계산하는 것 이상으로 유용한 정보 제공.
  - 종단(end-to-end) 대기 시간(latency)
- `window.performance` 객체의 속성으로 사용 가능.

### 내비게이션 타이밍 속성

- `window.performance.timing` 이벤트 속성은 탐색과 페이지 로드 이벤트에 대한 데이터를 가짐.
- `timing` 객체의 `key`에 해당하는 속성들은 `API`에서 정의한 웹 브라우저가 웹 페이지를 로딩 시 실행하는 각 단계.
  - `value`는 이 단계가 완료된 시간을 Unix Epoch Time 형식으로 변환한 값.
  - 페이지 요청 등의 탐색 이벤트 시간이나 `DOM` 로딩 시작 등의 페이지 로드 이벤트 시간을 1970년 1월 1일 자정부터 측정한 `UTC` 형식의 밀리초 단위로 나타냄.
  - 해당 값이 `0`이면 이벤트가 발생하지 않았다는 의미.
- 이 값들을 통해 각 단계가 언제 완료되었는지, 어떤 특정 항목에서 예상보다 시간이 지체되었는지 확인 가능.

참고

- [W3C - Navigation Timing](https://www.w3.org/TR/navigation-timing/)

### 내비게이션 타이밍 속성값 구하기

- `window.performance.navigation` 이벤트 속성은 사용자가 어떻게 페이지를 탐색하는가를 조사.
- 페이지 재전송 속성, 앞 뒤 이동 버튼이나 `URL`이 어떤 페이지 로딩을 발생시키는지(trigger) 확인하는 속성을 저장.
- `window.performance.navigation.redirectCount` 속성
  - 페이지 내에서 재전송이 몇 번 발생했는지 알려줌.
- `window.performance.navigation.type` 속성
  - 사용자가 해당 웹 페이지에 어떻게 접속했는지에 관한 정보를 알려줌.
    | 상수 | 값 | 설명 |
    | :-----------------: | :---: | :---------------------------------------------: |
    | `TYPE_NAVIGATE` | `0` | 링크, 북마크, 폼 전송, `URL` 브라우저 타이핑 등 |
    | `TYPE_RELOAD` | `1` | 브라우저의 새로고침 버튼 |
    | `TYPE_BACK_FORWARD` | `2` | 뒤로가기 버튼 |
    | `TYPE_RESERVED` | `255` | 그 외의 방법 |
- 내비게이션 타이밍 `API`에 포함된 각 속성값을 사용하면 다양한 성능 지표를 얻을 수 있음.
  ```js
  const pertData = window.performance.timing;
  // 사용자가 자각하는 로드 시간 구하기
  const notice_pageLoadTime = Date.now() - perfData.navigationStart;
  // 페이지 전체 로드 시간 구하기
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  // HTTP 요청에서 응답까지 걸린 시간 구하기
  const connectTime = perfData.responseEnd - perfData.requestStart;
  ```
- `pageLoadTime`이 크다면 웹 사이트 최적화, 콘텐츠 수나 크기를 줄여 로딩을 빠르게 해야 함.
- `connectTime`이 크다면 웹 서버를 좀 더 빠르게 연결할 수 있는 방법을 찾아야 함.
  - 웹 서버가 위치한 데이터 센터 사이에 지연 현상이 발생되는 원인 탐색, 응답을 빠르게 할 수 있도록 전달망 품질 개선 등.
