# 웹에서 가속을 이끌어 내는 방법

## 웹 브라우저 현황 알아보기

> 브라우저가 페이지를 화면에 렌더링하는 방식을 이해하고 이를 최적화하는 것이 프론트엔드 최적화의 핵심.

- 구글 크롬 브라우저: 전 세계에서 가장 많이 사용됨.
- 사파리, 파이어폭스: 데스크탑 브라우저에서 많이 점유.
- 사파리, 삼성 인터넷 브라우저: 모바일 브라우저에서 많이 점유.

> 국내에서는 `IE`가 고점유 브라우저였으나, 최근 크롬 브라우저가 따라 잡음.  
> 모바일 브라우저는 크롬 다음으로 삼성 인터넷 브라우저.

- 브라우저별로 지원하는 이미지 타입이 다르므로 점유율이 높은 브라우저에 대한 이미지를 별도로 준비하는 것이 효율적.
- 많은 브라우저가 저마다의 특징을 가지고 작동.
- 렌더링하는 방식에는 큰 차이가 없어 표준 방식으로 작성된 `.html` 파일을 해석하고, 이에 맞도록 객체를 생성하며 화면 크기에 맞추어 원하는 그림을 그림.

---

## 웹 브라우저 동작 이해하기

- 사용자가 입력 창에 접속하고자 하는 웹 사이트 주소를 입력함으로써 브라우저의 동작이 시작.
- 브라우저가 웹 사이트의 주소를 이용해 서버로부터 웹 페이지를 다운로드하기까지의 흐름
  1. 도메인 서버와 통신하여 접속하려는 호스트의 `IP`를 찾음.
  2. 해당 `IP`를 가진 서버와 통신을 시도해 `TCP` 연결을 맺음.
     - `HTTPS`에선 암호화된 연결을 생성하려는 협의 단계가 추가.
  3. 연결이 맺어지면 브라우저는 서버로부터 필요한 리소스들을 다운로드해 이를 화면에 표현.
- 리소스 다운로드 흐름
  1. 방문 페이지(landing page)의 `HTML` 을 서버에 요청해 다운로드.
  2. `HTML`의 구문을 분석(parsing)하면서 `HTML` 태그에 참조된 `CSS`, `JavaScript`, 이미지, 폰트 등의 하위 리소스들을 차례로 다운로드.

### 브라우저 아키텍처

1. 유저 인터페이스
   - 이 컴포넌트는 사용자가 브라우저를 통해 상호 작용할 수 있도록 도움.
   - 저마다 이름과 모양이 다른 브라우저들도 주소 입력 창, 북마크, 앞 뒤 버튼 등 사용자와 상호 작용을 위해 동일하게 제공하는 필수 기능들을 가지고 있음.
   - 추가로 브라우저별 차별화된 기능을 제공.
2. 브라우저 엔진
   - 유저 인터페이스와 렌더링 엔진 사이에서 렌더링 상태를 조회하고 렌더링 작업을 제어하기 위힌 인터페이스를 제공.
3. 렌더링 엔진
   - `HTML`을 분석하여 그대로 표현하거나 `CSS`를 분석해 웹 페이지를 꾸미기도 하는 등 실제 웹 콘텐츠를 원하는 대로 브라우저 창에 그리는 역할.
   - `Webkit`(사파리), `Gecko`(파이어폭스), `Blink`(크롬), `Trident`(인터넷 익스플로러) 등의 렌더링 엔진이 있음.
4. 네트워킹
   - 네트워크를 통해 `HTTP` 요청을 보내고 응답받는 역할.
   - `DNS` 조회, `TCP` 연결 등의 작업 수행.
   - 브라우저별로 6-10개 스레드로 동시 `TCP` 연결을 생성해 리소스들을 신속히 다운로드 가능.
5. `UI` 백엔드
   - 콤보박스, 드롭박스 등 기본적인 `UI` 컴포넌트들을 제공.
6. `JavaScript` 해석기
   - `V8`, `Spider Monkey` 등의 엔진을 사용하여 `JavaScript`를 분석하고 해석.
7. 데이터 저장소
   - 데이터 지속성(persistence)을 유지하기 위한 컴포넌트.
   - 쿠키 값을 로컬 디스크에 저장하는 등.
   - `HTML5`에서는 로컬 스토리지, `IndexDB` 등을 이용해 더 많은 데이터 저장 가능.

- 사용자 요청을 처리하고 웹 사이트를 표현하기 위해 모든 컴포넌트들이 유기적으로 동작.

> 실제로 `HTML`을 처리해 화면에 렌더링하는 컴포넌트는 렌더링 엔진.

### 중요 렌더링 경로

- 렌더링 엔진이 웹 페이지를 구문 분석해 화면에 표현하는 일련의 작업은 선후 관계가 비교적 명확하므로 단일 스레드에 의해 수행.
  - `Ex) HTML이 해석되지 않으면 CSS와 JavaScript가 수행될 수 없고, 객체 모델이 만들어지지 않으면 브라우저가 화면을 구성할 수 없으며, 화면을 구성하지 못하면 결국 페이지를 그리지 못함.`

1. `HTML`을 가장 처음 구문 분석하면서 `DOM` 트리를 만듬.
2. `CSS`를 구문 분석하여 `CSSOM` 트리를 만듬.
3. 두 개의 트리 모델을 결합해 최종적으로 렌더 트리를 만듬.
4. 렌더 트리가 생성되면 브라우저는 페이지 구조를 결정하고 화면에 표현.

#### `DOM` 트리 생성

- `HTML`의 구문을 분석해 태그를 하나하나 해석하여 `DOM`이라는 객체 모델로 변환.
- `DOM`(Document Object Model)은 객체 지향적 프로그래밍 언어들로 `HTML`이나 `XML` 형태의 마크업 문서들을 손쉽게 프로그래밍하기 위해 표준으로 규정한 프로그램 인터페이스.
- `HTML`이 `DOM`으로 바뀌면 프로그램 인터페이스로 원하는 태그를 조회/수정 가능.
  ```js
  const myElement = document.getElementById("intro");
  myElement.innerHTML = "Hello World!";
  ```
- `DOM`은 객체 속성과 메서드, 이벤트 등을 정의.

> 브라우저 구문 분석기는 위에서부터 순차적으로 `HTML`을 분석하며 부모 노드와 자식 노드와의 관계를 파악해 `DOM` 트리를 생성.

#### `CSSOM` 트리 생성

- `CSSOM`(CSS Object Model)은 `DOM`과 비슷하게 `CSS`를 처리하기 위한 트리 구조의 프로그래밍 인터페이스.
- 브라우저가 `HTML`을 구문 분석하며 `CSS`를 참조하는 링크를 만나면 해당 `CSS` 리소스를 다운로드하고 구문 분석기가 `CSS`를 분석하기 시작.
- `HTML`과 다르게 `CSS`는 구문 분석에 엄격한 구문 검사가 적용.
  - 구문 분석 방법이 다르다 보니 사용하는 구문 분석기와 동작 스레드도 다름.
  - 따라서 `HTML` 구문 분석 과정이 `CSS` 분석에 의해 방해받지 않음.
- `CSS`는 페이지 스타일 정보를 나타내므로 `CSSOM` 트리의 각 노드들은 고유한 스타일 속성을 포함.

> 중요 렌더링 경로 상에서 `DOM` 트리와 `CSSOM` 트리는 각각 별도로 생성되고 이후 렌더 트리로 통합.

#### 렌더 트리 생성

- `DOM` 트리와 `CSSOM` 트리의 구문 분석이 완료되면 브라우저는 두 개의 트리를 병합해 렌더 트리(`render tree`)를 생성.
- 렌더 트리: `DOM`과 `CSSOM`을 기반으로 렌더링을 위한 최종 정보를 가진 렌더 객체들을 생성해 이들의 상하 관계를 트리 모양으로 구성한 것.
  - 렌더링을 하는데 아무런 의미가 없는 노드는 제외됨.
  - 렌더 객체는 다음 레이아웃 단계를 수행하기 위한 모든 정보를 가지고 있음.
  - 한 개의 렌더 객체는 사각형 모양 영역 표현 가능.

#### 레이아웃

- 렌더 트리 노드들의 위치 정보가 계산되는 단계.
- 렌더 객체는 사각형 영역을 표시하므로 브라우저 창의 맨 왼쪽 위에서 시작하여 아래, 오른쪽으로 이동하며 각 사각형 영역의 너비와 높이 계산.
- 렌더 트리의 루트 노드로부터 계산이 시작되는데, 루트 노드의 너비는 뷰포트의 크기로 지정.
  - 자식 노드들의 너비가 비율로 되어 있다면 이 뷰포트 너비에서 각 자식 노드들의 너비가 계산.
  - 부모 노드에서 자식 노드로 재귀하여 반복 수행.
- 높이 계산은 역으로 자식 노드의 높이에 따라 부모 노드의 높이를 계산.
  - 재귀적으로 반복 수행하면서 노드들의 위치가 차례로 계산.

#### 페인트

- 페인트: 렌더 트리 정보를 바탕으로 브라우저 창에 표현하는 단계.
  - 렌더링을 위한 정보가 준비되어 있으므로 `GPU`를 이용해 그리기만 하면 됨.
- `JavaScript`는 `DOM`과 `CSSOM`을 동적으로 변경할 수 있으며, 이 경우 렌더 트리가 변경되고 레이아웃, 페인트 단계가 다시 수행.

---

## 브라우저 렌더링 최적화하기

### `DOM` 최적화하기

- `HTML`을 `DOM`으로 전환하는 과정은 구문 분석이 관대하다는 점에서 `XML`과 다름.
  - `XML`은 `DTD` 또는 `XML` 스키마를 이용해 정의된 구문을 엄격하게 따라야 함.
    - 그렇지 않으면 `XML`을 전달받은 애플리케이션이나 사용자가 콘텐츠의 내용을 잘못 이해해 오류 발생 유발.
  - `HTML`은 구문 체크에 관대하므로 작성 시 잘못된 습관이나 실수에 의해 문법 오류가 발생해도 브라우저에는 정상적으로 표현.
    - 이렇게 다양한 오류를 포용하기 위해 브라우저는 잘 알려진 수많은 오류 사항에 대한 예외 처리 방안을 구현.
      - 제한된 숫자 이상 중첩된 태그가 많음. => 내부 알고리즘에 의해 중첩된 태그 제거.
      - 태그를 열고 닫지 않음. => 적절한 위치에서 태그를 닫음.
      - 테이블 안에 테이블이 겹침. => 겹친 테이블을 분리.
        > 웹 페이지 내에 오류가 많을수록 브라우저는 예외 처리를 위해 더 많은 메모리와 `CPU` 파워를 소모.
  - `HTML`의 구문 오류를 최소화, 간소화하는 것이 웹 사이트 성능 향상시키는 기본적이고도 간단한 방법.
- 과도하게 `HTML` 태그를 중첩 사용하는 행위도 피해야 함.
  - 태그가 중첩되어 `HTML` 문서 구조가 복잡하게 작성되어 있으면, `JavaScript`에 의해 스타일이 변경될 때 각 태그의 레이아웃을 다시 계산하고 재구성하는 데 더 많은 리소스와 시간이 소요.
    > 일반적으로 중첩된 태그들이 15단계를 넘지 않도록 `HTML`을 구성하는 것을 권장.
- 도구
  - `DOM`을 분석해 최적화 방안을 알려주는 무료 도구 `DOM Monster`.

### `JavaScript`와 `CSS` 배치하기

- `HTML`과 `CSS`에서 사용하는 구문 분석 알고리즘과 스레드는 다름.
- `CSS` 구문 분석을 위해 `HTML` 구문 분석을 처리하는 스레드가 차단당하지는 않음.
  - 여기서 `JavaScript`가 중요한 역할을 수행.
    - `JavaScript`는 이미 생성한 `DOM`과 `CSSOM`을 언제든지 변경시킬 수 있기 때문.
- `HTML` 구문 분석기가 순차적으로 `HTML`을 해석하는 중 `JavaScript`를 만나면 이를 다운로드하고 수행이 완료될 때까지 `DOM` 생성 작업을 중단.
  - `JavaScript`에 의한 변경이 완료되기를 기다림.
- 이 시점에 특정 `CSS`에 대한 구문 분석 처리 및 `CSSOM` 생성 작업이 진행 중이라면 `JavaScript`가 변경하려는 스타일 시트가 아직 생성되지 않았을 수도 있음.
  - `JavaScript`는 `CSSOM` 생성이 완료될 때까지 수행을 중지하고 대기.
    - 원하는 스타일 시트가 채 생성되기도 전에 `JavaScript`가 이를 수정하려는 경우, 스크립트 오류가 발생해 만들고자 하는 웹 페이지가 생성되지 않음.

> 렌더링에 있어 `CSS`가 `JavaScript` 보다 더 높은 우선순위를 가짐.  
> 두 리소스 모두 전체 렌더링 과정을 지연시킬 수 있는 중요한 렌더링 방해 리소스.

- `CSS`와 `JavaScript`에 렌더링 방해를 피하는 방법
  - `CSS`는 최대한 소스 위쪽에 배치하여 `CSSOM`이 가능한 빨리 생성되도록 함.
  - `JavaScript`는 최대한 아래쪽에 배치.
  - `DOM`과 `CSSOM`이 모두 생성된 이후에 수행될 수 있도록 함.

> 해당 배치 약속을 잘 지킬 경우, 모든 리소스를 다운로드해 페이지 로딩이 완료되는 시점은 비슷하지만 렌더링 시작 시점에 큰 차이가 발생.

### `JavaScript` 최적화하기

- 최근의 웹 페이지는 타사 제공 리소스를 포함한 많은 수의 `JavaScript`를 사용.
  - 이로 인해 전체 페이지 로딩 시간이 지연될 수 있음.
- 페이지 로딩 시간이 길어지면 메뉴를 선택하거나 텍스트를 입력하는 등 사용자와 웹 페이지 간 상호 작용이 이루어지기 힘듬.
  - 구글의 경우 페이지 로딩 완료 시간을 검색 결과에 반영시키므로 검색 순위에도 악영향.
- `JavaScript`가 전체 페이지 로딩 시간에 영향을 주는 것을 막으려면 `JavaScript` 수행이 렌더링 스레드를 방해하지 않도록 별도 스레드로 `JavaScript`를 수행시켜야 함.
- 또한, 렌더링 작업이 어느 정도 끝난 이후 `JavaScript` 수행.
- `JavaScript`에서 제공하는 관련 속성
  ```html
  <script src="async_script.js" async></script>
  <script src="defer_script.js" defer></script>
  ```
  - `async` 속성은 구문 분석과 동시에 `JavaScript`를 다운로드하고 수행되도록 함.
    - 지연 수행 시 스크립트간 선후 관계를 따지지 않음.
  - `defer` 속성은 구문 분석 중에 별도의 스레드로 `JavaScript`를 다운로드하고 구문 분석이 끝난 이후 수행되도록 함.
    - 스크립트가 호출된 순서에 따라 차례로 수행.

> 대부분의 분석, 광고용 타사 스크립트들은 위 속성을 사용하여 메인 페이지의 렌더링 프로세스에 영향을 주지 않도록 구현.

- 주의할 점: 모든 `JavaScript`가 비동기나 지연 처리의 대상이 될 수 없다는 것.

  - `JavaScript`들은 많은 경우에 렌더링에 관여하도록 구현.
  - 또한, 스크립트 사이에 종속 관계가 있을 수 있으므로 비동기 처리나 지연 처리를 무분별하게 적용하면 원치 않게 화면이 일그러지는 현상이 발생.
    - 이를 피하기 위해서는 페이지에 사용되는 `JavaScript`들을 초기 렌더링에 꼭 필요한 그룹과 그렇지 않은 그룹으로 분류에 후자의 그룹에 `async`, `defer` 속성을 적용.
  - 더 확실한 방법으로 브라우저가 페이지 로딩을 명시적으로 끝낸 후 나머지 스크립트들을 수행시키는 방법 사용 가능.

    ```html
    <!-- critical JS -->
    <script src="assets/js/jquery-1.10.2.min.js"></script>
    <!-- non-critical JS -->
    <script t="assets/js/gridpak.js"></script>
    <script t="assets/js/bootstrap.js"></script>
    <script type="text/javascript">
      function deferOnload() {
        const element = document.getElementsByTagName("script");
        for (let i = 0; i < element.length; i++) {
          element[i].src = element[i].getAttribute("t");
        }
      }

      if (window.addEventListener) {
        window.addEventListener("load", deferOnload, false);
      } else if (window.attachEvent) {
        window.attachEvent("onload", deferOnload);
      } else window.onload = deferOnload;
    </script>
    ```

### `CSS` 최적화하기

- 브라우저는 `CSS`가 구문 분석되고 `CSSOM`이 만들어지기까지 렌더링을 멈추므로 `CSS`는 렌더링 순위가 가장 높으면서 동시에 렌더링을 가장 방해하는 리소스.
- 사용자가 기기 화면으로 볼 수 있는 내용은 제한적이므로 모든 `CSS`가 쓰일 수는 없음.
  - 일부 스타일 정보만 첫 화면 렌더링에 사용되고 나머지는 탭으로 숨겨진 부분이나 스크롤을 내려야 보이는 화면 아래쪽 등 잠재적으로 나타날 화면 렌더링에 사용.
  - 또한 개발 편의성 또는 `RTT` 감소 목적으로 여러 페이지에 다르게 적용될 스타일 정보들을 한 파일에 통합하면 오히려 렌더링 시작을 지연.
- `CSS`는 필요한 정보만 빠르게 다운로드하고 실행해야 브라우저 렌더링을 가속시킬 수 있음.
  1. `CSS`를 적절히 분리하여 필요한 페이지에 필요한 `CSS` 파일만을 포함.
  2. 첫 화면에 사용될 `CSS` 파일과 숨겨진 화면에 사용될 `CSS` 파일을 분리행 후자의 `CSS`는 지연 수행.
- 필요한 `CSS`만 다운로드하려면 미디어 쿼리를 활용
  ```html
  <link
    rel="stylesheet"
    type="text/css"
    media="screen and (max-device-width: 480px)"
    href="styles_base.css"
  />
  <link
    rel="stylesheet"
    type="text/css"
    media="screen and (min-device-width: 781px)"
    href="styles_desktop.css"
  />
  <link
    rel="stylesheet"
    type="text/css"
    media="screen and (max-device-width: 780px) and (min-device-width: 481px)"
    href="styles_mobile.css"
  />
  ```
- 숨겨진 화면에 적용될 `CSS` 파일들을 `onLoad` 이벤트 발생 이후 처리하는 방법

  ```html
  <!-- CSS for above the fold -->
  <link
    rel="stylesheet"
    media="all"
    type="text/css"
    href="assets/css/gridpak.css"
  />

  <!-- CSS for below the fold -->
  <link
    rel="stylesheet"
    media="all"
    type="text/css"
    defer-ref="assets/css/bootstrap.css"
  />
  <link
    rel="stylesheet"
    media="all"
    type="text/css"
    defer-ref="assets/css/site.css"
  />

  <script type="text/javascript">
    function deferOnload() {
      const styles = document.getElementsByTagName("link");
      for (let i = 0; i < styles.length; i++) {
        const href = styles[i].getAttribute("defer-ref");
        if (href) {
          styles[i].href = href;
        }
      }
    }

    if (window.addEventListener) {
      window.addEventListener("load", deferOnload, false);
    } else if (window.attachEvent) {
      window.attachEvent("onload", deferOnload);
    } else window.onload = deferOnload;
  </script>
  ```

### 이미지 로딩 최적화하기

- 웹 최적화에 있어 이미지 압축은 필수일 정도로 이미지 로딩 최적화는 다른 방법들에 비해 효율적.
- `CSSOM`에 `display: none;` 등의 속성이 적용되면 렌더 트리에 나타나지 않으므로, 이미지의 경우 이를 다운로드 하지 않아햐 하지만 `DOM`과 `CSSOM`이 별도 분석되고 생성되기 때문에 브라우저는 이를 알지 못하고 `DOM` 트리에 나타난 객체들을 모두 다운로드.
- 화면 렌더링에 필요하지 않은 이미지를 다운로드하지 않는 방법
  1. 그 이미지가 웹 사이트의 주요 이미지가 아니라면 `CSS`의 `background-image` 속성을 사용해 원하지 않는 다운로드를 피할 수 있음.
     - `CSS`를 분석할 때 숨겨질 이미지는 미리 알고 다운로드 하지 않기 때문.
  2. `JavaScript`를 이용한 지연 로딩 방식을 적용해 불필요한 다운로드를 피할 수 있음.
  3. `Progressive JPG`를 사용.
     - `Progressive JPG`는 고품질 이미지를 한 번에 전송하지 않고 분할 전송하는 방식으로 브라우저에서는 초기에 저품질 이미지가 보이지만 점차 원래 품질을 회복함.
     - 인터넷 속도가 빠른 구간에서는 큰 차이를 느낄 수 없지만, 인터넷 속도가 느린 구간에서는 사용자가 이미지를 빠르게 볼 수 있어 많은 이점 보유.
- 이미지 지연 로딩이 브라우저 로딩 속도 개선에 효과적일 수 있으나 사용자 경험 개선에는 항상 도움이 되진 않음.
  - 모든 이미지에 지연 로딩을 적용하면 브라우저의 프리로더가 이미지를 다운로드할 수 없으므로 오히려 성능을 저해하는 요소가 됨.
    > 지연 로딩은 첫 화면에 등장하지 않거나 숨겨진 이미지들을 다운로드하는 데만 사용을 권장.

> TIP. 구문 분석 도중 `CSS`, `JavaScript` 태그를 만나면 분석을 중단하고 관련 리소스들을 다운로드하고 실행한 후 다시 다음 태그를 처리함.  
> 대부분의 브라우저들이 버전을 거듭하며 이를 개선하려고 노력하였고, 이 노력의 일환으로 개발된 "프리로더"는 브라우저 자원의 효율적 사용을 위해 렌더링 스레드와 별도 스레드로 실행.  
> 그리고 다운로드할 수 있는 리소스들을 동시에 받아 놓음.  
> 프리로더는 `<img src="URL">`과 같이 `HTML` 표준에 정의된 태그와 속성만을 분석해 다운로드함.  
> 그러므로 사용자 정의 속성을 활용하는 지연 로딩 방식에는 적용되지 않음.

---

## 도메인 분할 기법 이용하기

- 도메인 분할 기법(domain sharding): 여러 도메인을 소유한 경우 웹 콘텐츠를 병렬적으로 동시에 다운로드할 수 있도록 하는 방법.
- 브라우저는 `HTTP/1.1` 프로토콜 하에 동일 도메인에 순차적(sequential) 다운로드 방식을 사용.
- 도메인 분할은 달리 보면 `HTTP/1.1` 프로토콜 하에서 브라우저의 제약을 피하는 방법.
  - 브라우저는 동일 호스트 명의 동시 연결 개수를 제한.
  - 한 도메인 당 6~13개의 `TCP` 연결들을 동시에 생성해 여러 리소스를 한 번에 다운로드 할 수 있도록 허용.
    - 6개의 동시 연결을 지원하는 브라우저에서 2개의 도메인을 이용하면 이론적으로 12개의 연결 가능.
  - 콘텐츠의 특징에 따라 도메인을 나누어 병렬로 동시 다운로드한다면 전반적인 다운로드 완료 시간이 앞당겨짐.
    - 예제
      - `www.feokorea.com`: 웹 사이트 메인 페이지 및 동적 콘텐츠
      - `img.feokorea.com`: 이미지 호출
      - `script.feokorea.com`: `JavaScript` 파일, `CSS`와 같은 정적 콘텐츠
      - `api.feokorea.com`: `API` 서비스
- 이러한 도메인 분할 기법을 이용하면 사이트 전체의 쿠키 사이즈를 축소할 수 있는 장점.
  - 최근의 웹 사이트는 사용자 개개인에 최적화된 페이지를 제공하는 맞춤형 전략 사용.
    - 사용자 정보를 브라우저 쿠키에 저장해두고 그 사용자가 방문할 때마다 브라우저에서 보내주는 쿠키 정보를 참조.
    - 개인화가 심화될 수록 쿠키에는 더 많은 정보가 저장되고 쿠키도 점점 커짐.
- 도메인을 분할하는 방법은 기술적으로 어렵지 않지만, 몇 개로 운용하는 것이 최적인지 결정하는 데는 좀 더 면밀한 계획과 테스트가 필요.

  - 하나의 웹 페이지에 포함된 리소스 개수가 얼마나 많은가에 따라 추가할 서브 도메인의 숫자를 결정.
    - 너무 많은 도메인을 추가하면 오히려 브라우저의 성능을 저하시킬 수 있으므로 주의.
    - 동시 다운로드 숫자가 많아질 수록 브라우저는 더 많은 `CPU` 리소스를 사용.
    - `CPU` 리소스가 한계에 도달하면 오히려 다운로드 속도를 느리게 함.
    - 브라우저는 각 도메인에 대한 `DNS` 조회를 수행하고 `TCP` 연결을 생성하며 생성된 도메인에 대한 연결을 유지해야 하므로 결국 페이지 로딩 속도를 현저히 떨어뜨림.
  - 최신 컴퓨터의 `CPI` 파워 및 네트워크 속도를 감안할 때 리소스 숫자에 따라 도메인 수를 결정하는 것이 바람직.

    ```
    가정
    페이지 당 평균 다운로드 리소스 수: 120
    목표 응답 시간: 2초
    평균 다운로드 속도: 300ms
    브라우저 동시 연결 수: 6개(크롬 기준)

    도메인 개수를 Nd라고 할 때, 응답 속도는 아래와 같이 계산할 수 있다.
    총 연결 수: 6 x Nd
    연결 당 다운로드 횟수(Np): 120/6Nd
    응답 시간: Np x 300ms = 2000ms
    도메인 개수(Nd): 3
    ```

  - 사용할 도메인 개수가 정해지면 그 수에 맞도록 리소스들을 균등 분할하는 것을 권장.
    - 특정 도메인에서 대부분의 리소스를 다운로드한다면 다른 도메인들은 오히려 `TCP` 연결을 위한 리소스만 낭비하게 되므로 차라리 없애는 것을 추천.

- 리소스들을 분류하는 방법
  1. 리소스의 성격에 따라 분류하는 방법
     - `JavaScript`, `CSS`, 폰트 같은 다양한 렌더링과 이미지, 멀티미디어 리소스들을 종류별로 구분하고 그 수를 파악해 도메인별로 균등하게 분배되도록 그룹화하는 방법.
     - 그룹화된 리소스들의 성격에 따라 도메인을 정하면 관리도 더 편함.
  2. 동적으로 분류하는 방법
     - 특정 리소스에 항상 같은 도메인이 배정되도록 해야만 캐시 적중률이 높아짐.
       - 해시 방식을 사용. 해시 함수를 통해 파일명을 숫자 배열로 변경하고 숫자에 따라 도메인을 결정하는 방식.

### 도메인 분할 기법과 `HTTP/2`

- 도메인 분할 기법은 `HTTP/1.1`의 가장 큰 문제점인 Head Of Line Blocking 현상 때문에 고안.
  - `HTTP/1.1`에서 클라이언트와 서버 간의 연결은 하나의 차선만 있는 도로와 같음.
  - 클라이언트는 하나의 요청을 서버에 보내고 그에 대한 정상적 응답을 받은 후에야 다음 요청을 서버로 보낼 수 있음.
- 위 문제점은 `HTTP/2`의 멀티플렉싱 기술로 해결되어 도메인 분할 기법을 사용할 이유도 자연스럽게 사라짐.
  - 도메인 분할 기법을 사용하면 오히려 `HTTP/2`만의 특징인 헤더 압축 전송, 우선순위 전송, 서버 푸시 기능을 방해하므로 사용하지 않는 것을 추천.
- `TCP` 연결을 병합(connection coalescing)하는 방식: 최근 사용되는 브라우저이 `HTTP/2`의 기능을 저해하지 않으면서 다중 도메인을 사용할 수 있는 방안.
  - 연결 병합은 브라우저가 첫 번째 도메인과 맺은 `TCP` 연결은 나머지 도메인에게 재사용하는 방식.
  - 이 기술이 적용되기 위해 고려해야 할 사항
    1. 브라우저가 `DNS`를 확인할 때 각 도메인은 모두 동일한 `IP` 주소를 반환.
       - 브라우저들은 `HTTP/2` 적용 시 도메인 명이 다르더라도 각 도메인의 `IP`가 같으면 먼저 생성ㄷ된 `TCP` 연결을 재사용해 하나의 연결로 처리.
    2. 동일한 인증서를 사용.
       - 도메인들이 동일한 `IP`를 사용해도 인증서가 다르면 암호화된 연결을 위해 각자 `TLS` 협상을 시도하고 이는 곧 추가적인 `TCP` 연결을 생성한다는 의미.
       - 하나의 인증서가 다수 도메인을 포함하려면 와일드카드 인증서나 `SAN` 인증서를 사용하면 됨.

> 두 가지 사항만 잘 지켜진다면 `HTTP/1.1` 사용자와 `HTTP/2` 사용자를 모두 고려한 도메인 분할 전송 환경을 성공적으로 구상 가능.

---

## 사용자 경험 개선하기

- 브라우저 성능 지표만을 향상시킨다고 해서 실제 사용자가 느끼는 성능이 향상되는 것은 아님.

### 사용자 경험 지표 바로 알기

- 내비게이션 타이밍 `API`의 다양한 이벤트들은 브라우저의 화면 렌더링에 대한 유용한 정보들을 제공하기 때문에 지금까지 성능 지표로써 유용하게 사용되어 옴.
- `JavaScript`를 사용하여 `onLoad` 이벤트 이후에도 많은 기능들을 처리할 수 있게 됨으로써, `페이지 로딩 시간 = 시각적 완료 시간`이라는 룰은 오래전에 깨짐.

> 웹 사이트의 성능 지표가 브라우저 이벤트 중심 지표에서 사용자 중심 지표로 변화하고 있음.

- 사용자 중심 지표
  - `WebPageTest`의 `Speed Index`: 시간에 따른 웹 사이트의 시각적 진행 상태를 수치화한 지표로, 값이 작을수록 시각적 진행 상태가 빠르다는 것을 의미.
  - 구글 크롬 팀을 주축으로 다양한 사용자 중심 성능 지표 개발 중.
    - 첫 번째 콘텐츠가 있는 페인트(First Contentful Paint)
    - 상호 작용 시간(Time to Interactive)
  - `W3C` 컨소시엄이 제시한 사용자 경험의 단계에 따른 주요 지표
    - 사용자 경험: 작동하는가?
      |지표|의미|강점|제약사항|
      |:-:|:-:|:-:|:-:|
      |`Back-end Time` / `Time To First Byte`|서버로부터 첫 바이트를 수신하기까지 시간|`W3C` 표준|시각적인 진행 상태를 알려주지 않음|
      |`First Contentful Paint`|첫 콘텐츠의 첫 픽셀이 그려지는 시간|시각적 진행 상태를 알려줌|크롬에서만 지원|
      |`Start Render` / `First Paint`|공백을 포함한 첫 픽셀이 그려지는 시간|렌더링 시작을 알려줌|브라우저별 정의가 상이함|
    - 사용자 경험: 유용한가?
      |지표|의미|강점|제약사항|
      |:-:|:-:|:-:|:-:|
      |`Visually Ready`|브라우저 화면에 콘텐츠가 시각적으로 완료되는 시점|다양한 지표를 복합적으로 고려|일부 툴에서만 사용됨|
      |`Speed Index`|브라우저의 시각적 완료 단계를 정량적으로 계산|`Adove The Fold`에 대한 정확성|실험적 지표|
      |`Largest Contentful Paint`|주요 콘텐츠를 볼 수 있는 시점|`Adove The Fold`에 대한 정확성|크롬에서만 지원|
    - 사용자 경험: 사용 가능한가?
      |지표|의미|강점|제약사항|
      |:-:|:-:|:-:|:-:|
      |`First Input Delay`|사용자의 최초 입력에 브라우저가 반응하는 시간|사용자 만족도를 반영함|크롬에서만 지원|
      |`Time to Interactive`|사용자와 상호 작용이 가능해지는 시간|페이지 준비 완료 시점에 대한 지표를 알려줌|정확히 상호 작용이 기능한 시점을 의미하는 것은 아님|
    - 사용자 경험: 즐가운가?
      |지표|의미|강점|제약사항|
      |:-:|:-:|:-:|:-:|
      |`Long Task Time`|`50ms` 이상의 장기 작업 소요 시간|사용자와 상호 작용에 문제가 있는지 알려줌|지연을 판단할 명확한 기준이 없음|

### 사용자 요청에 빠르게 반응하기

- 웹 사이트 방문자에게 첫 응답 속도는 마치 사람의 첫 인상처럼 중요함.
  - 인간은 응답 속도가 `100ms` 늦어질 때 이를 인지할 수 있고, `1s`가 늦어지면 지연으로 인식.
- 사용자 요청에 바르게 반응하려면 기본적으로 서버의 응답이 빨라야 함.
- 브라우저가 서버에서 응답한 첫 번째 바이트를 수신하는 시간(`TTFB`, Time To First Byte)이 `300ms` ~ `500ms`인 것이 일반적으로 가장 이상적.
  - 이를 위해 `HTML` 내의 주석이나 공백 등 불필요한 코드들을 모두 제거하여 전송되는 바이트 크기를 줄여야 함.
  - `HTML` 페이지를 캐시하여 서버 처리 시간을 최소화하는 것을 권함.
- `HTML` 파일 다운로드 후 브라우저가 1초 이내에 화면 렌더링을 시작해야 사용자가 지연을 느끼지 않음.
  1. `CSS`, `JavaScript` 파일 크기를 줄여야 함.
     - 공백과 주석을 제거하는 방법.
     - 근본적으로 렌더링할 페이지에 필요한 부분만 남기고 필요하지 않은 부분은 제거하는 방법이 더 좋음.
       - 크롬 브라우저의 `[도구 더보기]` -> `[개발자 도구]` -> `[Customize and control DevTools]` -> `[More tools]` -> `[Coverage]` 모듈을 사용하면 해당 페이지에서 실제로 사용되고 있는 코드를 알려줌.
     - `HTTP/2` 특징 상 요청 수와는 상관없이 전체 리소스의 크기를 줄여야 다운로드 속도가 향상됨.
       > 이 리소스 파일들을 여러 개의 작은 파일들로 분리해 특정 페이지에 필요한 리소스들만 다운로드하면 전체 리소스 크기를 크게 줄일 수 있음.
  2. `CSS`, `JavaScript`들을 중요 리소스와 그렇지 않은 리소스로 분류.
     - 화면 안쪽(above the fold)의 웹 콘텐츠를 렌더링하기 위한 파일들이 중요 리소스.
     - 화면 바깥쪽(below the fold)의 콘텐츠를 렌더링하기 위한 파일, 부가적인 기능 들을 수행하는 스크립트 파일들이 중요하지 않은 리소스.
  3. 위에서 분류된 중요 리소스들을 가능한 빠르게 로딩시킴.
     - 리소스 힌트 `preload`를 사용하는 방법.
     - `HTTP/2`에서 서버 푸시를 활용하는 방법.
       - 서버 푸시는 최초의 `HTML`이 다운로드되는 시점에 이루어지기 때문에 `preload`에 비해 훨씬 빠르게 중요 리소스들을 다운로드 가능.
  4. 중요하지 않은 리소스들은 나중에 로딩시킴.
     - `JavaScript`에 `async`나 `defer` 속성을 사용하거나 `onLoad` 이벤트 이후에 수행하도록 지연시킬 수 있음.
       - `CSS`도 `JavaScript`를 사용하여 지연 가능.

### 사용자 시선 붙잡기

- 사용자가 이탈하지 않도록 시선을 붙잡으려면 `Hero` 이미지가 가능한 빠르게 화면에 로딩되어야 함.
- `Hero` 이미지가 늦게 로딩되는 주된 이유는 페이지 로딩 시간을 개선하기 위해 모든 이미지들을 일관적으로 지연 로딩시키기 때문.
  - 지연 로딩은 `JavaScript`에 의해 수행됨.
  - `JavaScript`는 중요 렌더링 순서 상 `DOM`, `CSSOM`이 만들어진 후에야 수행.
  - 때문에 이를 사용한 이미지 다운로드 시작 시간도 늦어짐.
- 일반적으로 브라우저의 프리로더 스레드가 메인 스레드와는 별도로 페이지 내의 리소스들을 미리 다운로드 가능.
  - 그러나, 지연 로딩이 적용된 이미지들은 이 프리로더 대상에 포함되지 않음.

> 이미지 지연 로딩은 `Hero` 이미지들을 제외한 나머지 이미지들에 적용해야 함.

- `Hero` 이미지가 늦게 로딩되는 또다른 이유는 `CSS`의 `background-image` 속성으로 지정되었을 경우.
  - `HTML`의 `<img>` 태그로 지정된 이미지들은 `HTML` 구문 분석과 함께 다운로드됨.
  - `CSS`의 `background-image` 속성으로 지정된 이미지들은 `CSS`가 분석되고 `DOM`에 적용될 때 다운로드되고, 프리로더에도 적용되지 않음.
  - 그러므로 다른 이미지들보다 훨씬 늦게 다운로드됨.
- `Hero` 이미지를 일찍 로딩하여 사용자 경험을 향상시키기 위한 규칙
  1. `HTML`의 `<img>` 태그나 `<picture>` 태그를 사용하여 직접 다운로드하고 지연 로딩을 적용하지 않음.
  2. `CSS`의 `background-image` 속성에 `Hero` 이미지를 사용하지 않음.
  3. `CSS` 배경 이미지로 `Hero` 이미지를 꼭 사용해야 한다면 리소스 힌트인 `preload`를 사용해 일찍 다운받음.
- 메인 텍스트(main text) 역시 의미 있는 콘텐츠를 구성.
- 브라우저에서 텍스트는 폰트를 먼저 다운로드해야 비로소 표현되므로 핵심 메세지를 사용자에게 빠르게 나타내려면 폰트를 빨리 다운로드해야 함.
  - 폰트는 페이지 로드 시간을 결정하는 핵심적인 리소스인데도 `CSS`의 `font-face` 속성을 통해 로딩되므로 일반적으로 이미지들보다 다운로드 시작 시점이 늦음.
  - 이를 개선하려면 리소스 히트인 `preload`를 사용하여 필요한 폰트를 일찌감치 다운로드하는 것을 권장.
- 한글 폰트는 총 11,172자를 포함하므로 폰트 파일의 크기가 매우 큼.
  - 이 경우 `preload`를 사용해 일찍 다운로드하면 다른 중요 리소스들의 다운로드 속도가 늦어져 결국 렌더링 시작 시간이 늦어지는 부작용 발생 가능성.
  - 따라서 `preload` 이전에 폰트 파일을 경량화해야 함.
- 크기가 큰 폰트 파일을 분석하면 다양한 국가의 언어, 다양한 서체들에 대한 글리프(`glyph`)들을 모두 포함하고 있는 경우가 많음.
  - 온라인 폰트 분석 툴로 폰트를 분석해보면 자신이 사용하고 있는 폰트가 어떤 글리프들을 포함하는지 쉽게 파악 가능.
    - 하나의 웹 사이트에서 모든 글리프를 사용할 수 없으므로 필요한 글리프들만 모아 서브 세트를 만들 수 있음.
  - `KS X 1001` 표준에서 지정한 2,350자만 포함하도록 서브 세트 폰트를 만들면 파일 크기를 훨씬 줄일 수 있음.
  - 파이썬 기반의 `fonttools` 라이브러리가 잘 알려진 서브 세팅 툴.
- 폰트 경량화와 더불어 폰트 로딩 방식도 메인 텍스트를 빠르게 표현하는데 중요한 역할.
  - 크롬 브라우저는 웹 폰트가 다운로드될 때까지 3초를 기다리고 그 후에도 다운로드되지 않으면 시스템 폰트를 사용하며, 최종적으로 웹 폰트가 다운로드되면 시스템 폰트를 대체.
    > 웹 폰트를 완전히 다운로드한 후 텍스트를 나타내는 방식(`FOIT`, Flash Of Invisible Text)과 시스템 폰트를 먼저 사용 후 웹 폰트가 다운로드되면 대체하는 방식(`FOUT`, Flash Of Unstyled Text)을 혼합한 방식.
  - 사용자의 경험을 생각한다면 `FOIT` 방식보다 `FOUT` 방식을 사용하여 가능한 빠르게 사용자에게 메세지를 전달하는 것이 바람직.
  - `FOUT` 방식 사용법
    ```css
    @font-face {
      font-family: MyFont;
      src: url(/path/to/fonts/myFont.woff) format("woff2");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    ```

### 사용자 상호 작용 방해하지 않기

- 브라우저가 페이지를 시각적으로 완성했다 하더라도 버튼 클릭, 스크롤 등의 상호 작용이 원할하지 않으면 사용자들의 불만이 증가.
- 사용자의 상호 작용을 측정하는 Time to Interactive나 First Input Delay 같은 지표가 웹 사이트 평판을 가늠하는 훌륭한 지표가 될 수 있음.
  - 구글의 `Page Speed` 점수도 Time to Interactive 지표에 가장 높은 가중치.
- Time to Interactive 지표는 `CPU` 유휴 시간과 네트워크 사용량 등 클라이언트의 몇가지 물리적 지표에 의하여 결정.
  - 다운로드하는 리소스 약과 수행 스크립트를 줄이는 것이 가장 중요.
- 타사(`3rd party`) 리소스는 최적화하기 어려움.
  - 도입 전 면밀한 성능 검중, 도입 후 주기적인 점검, 사용이 완료되면 잊지 않고 제거하는 작업들이 필요.
  - `RequestMap`이나 `Ghostery` 같은 툴로 현재 웹 사이트에서 사용하고 있는 타사 리소스들의 현황 파악 가능.
- 타사 제공 리소슫르이 웹 사이트 성능에 영향을 주지 않게 하려면 그 리소스들을 호출하는 스크립트들이 비동기적으로 다운로드되어야 함.
  - 그렇지 않으면 단일 실패 지점(`SPOF`, Single Point Of Failure) 발생 가능.
  - 만약 그 타사 호스트가 리소스 다운로드 요청에 응답하지 않으면 내 웹 사이트 로딩도 덩달아 지연되므로 피해 발생 가능.
  - 사용하는 타사 리소스가 이러한 잠재적 장애 요소를 가지고 있는지 `SPOF-O-Matic`을 이용해 확인 가능.
