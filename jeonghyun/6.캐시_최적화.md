## 캐시

    서버와 클라이언트 사이에서 응답 컨텐츠의 사본을 저장하는 공간

| 종류                | 위치           | 이점                                                      |
| ------------------- | -------------- | --------------------------------------------------------- |
| 브라우저 캐시       | 브라우저       | 리소스 재사용                                             |
| 프록시 캐시         | 브라우저와 ISP | 조직내 사용하여 대역폭 사용률 감소, 사용자 로딩 시간 감소 |
| 트랜스패어런트 캐시 | ISP            | ISP간 대역폭 낭비를 막음                                  |
| 리버스 프록시 캐시  | ISP와 웹 서버  | 원본 서버로 향하는 트래픽 대역폭 감소, 사용자 응답 개선   |

#

## 동작 원리

    최초 요청에서 사본을 만들어 저장하고 같은 요청에 사본으로 응답한다.

### HTTP

    인터넷 데이터 통신 프로토콜

-   클라이언터 서버 모델로 동작
-   비연결성이며 상태를 유지하지 않는 프로토콜
-   HTTP 메세지를 주고 받으며 통신
-   메세지는 헤더와 바디로 구분됨
-   TCP 사용하는데 일반적으로 80포트 사용

### HTTP의 캐시 제어 방식

    목적: 원본 서버 요청 최소화, 리소스 낭비 줄임 및 비용 효율화

-   Expire - 원본 서버 컨텐츠의 유효 기간을 지정
-   Cache-Control: max-age - 캐시 유지 시간
    1. 첫 번째 요청은 원본 서버에 그대로 요청
    2. 유효기간 헤더에 명시
    3. 캐시 키와 함께 응답을 저장하고 만료일 설정 후 응답 전송
    4. 만료일이 지나지 않았다면 캐시 응답
-   Cache-Control: s-maxage - CDN과 같은 공용 캐시 주기 관리
-   ETag
    -   원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호
    -   리소스가 만료 되었는지 확인
-   Cache-Control: public - 사용자 제한 없이 모든 캐시 서버에 캐시
-   Cache-Control: private - 요청한 사용자만 캐시
-   Cache-Control: no-cache
    -   캐시된 응답을 받지 않는다는 의미
    -   캐시된 응답을 보내기 전에 원본 서버를 항상 확인시킴
-   Cache-Control: no-store - 서버는 로컬 저장소에 메세지를 저장하지 않음

### 캐시 유효성 체크

    기본적으로 age와 max-age을 비교해 캐시하는데
    리소스가 아무 변화 없는 경우 등을 처리하기 위해
    조건부 요청 정의

-   항상 원본 서버에서 완전한 컨텐츠를 받는 대신 TTL 주기 동안 변화가 있을 때만 새 응답 요청
-   시간 기반 - 컨텐츠의 최종 변경 시간 중심으로 확인

    1. 응답할 때 Last-Modified 헤더에 변경 날짜와 시간을 같이 적음
    2. TTL이 지난 후 같은 요청이 왔을 때 If-Modified-Since에 날짜를 적어 요청
    3. 이 날짜 이후에 변경이 있다면 완전한 응답
    4. 없다면 코드가 담긴 응답

-   컨텐츠 기반 - 컨텐츠가 캐시에 저장된 후 변경 여부

### 캐시 컨텐츠 갱신

-   퍼지: 저장소를 완전히 지우는 방식
-   무효화: 조건부 요청을 통해 캐시된 리소스 중 변경된 리소스만 갱신

#

## 캐시 최적화 방안

1. 최대한 많이 캐시
2. 최대한 오래 키시
3. 최대한 가까이 캐시

### 캐시 가능히나 컨텐츠 구분하기

|      | 정적 컨텐츠              | 동적 컨텐츠            |
| ---- | ------------------------ | ---------------------- |
| 정의 | 호출 마다 변함 없는 응답 | 요청마다 생성되는 응답 |
| 예시 | CSS, JS                  | JSP, ASP, PHP          |

#### 캐시하기 어려운 컨텐츠

-   개인화 된 컨텐츠
-   API 호출, AJAX 요청
-   Beacon 전달 또는 쿠키 설정을 위한 호출

### 올바른 캐시 정책 설정

1. 캐시할 수 있는 컨텐츠인지 판단
2. 캐시할 수 있는 컨텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단
3. 캐시할 컨텐츠들의 성격을 판단
4. 마지막으로 캐시 주기를 설정하고 max-age 추가

### 캐시 주기 설정

1. 캐시 주기는 컨텐츠 타입별로 다르게 설정
2. 링크 변경 없이 이미지 내용만 바꿔야 한다면 캐시 무효화 방식으로 이미지민 캐시 업데이트
3. 모든 정적 파일에 대해 캐시 주기를 길게 설정하고 수동으로 캐시 주기를 관리하는 방법

### 캐시에 적합한 디렉터리 구조 구성

1. 캐시할 수 있는 컨텐츠들을 별도 폴더에 분류 관리
2. 캐시 주기별로 나누어 구성
3. 동일한 파일을 여러 곳에 분신시키지 않아야 함

### 캐시 올바르게 사용하기

-   일반적인 캐시 키 구성
-   캐시 오염(원본 하나 여러 사본)과 캐시 충돌(요청 URL이 하나인데 브라우저 환경에 따라 응답이 달라져서 최초 요청만 캐시)
-   캐시 오염 제거
    1. 쿼리 스트링이 달라도 응답이 같다면 쿼리 스트링 무시
    2. 쿼리 스트링 순서 동일하게 정렬
    3. Vary 헤더
    4. 캐시 충돌 방지

### CDN 사용

#

## 동적 컨텐츠 캐시

### 동적 컨텐츠 캐시

1. 동적 정보를 쿠키에 넣어 보낸다.
    - 보안 주의: 개인 정보가 포함되어 있을 수 있음
    - 캐시 서버 용량 유의: 용량 소진시 지우는 데에 CPU 사용량이 늘어 효율이 떨어짐
2. Ajax 요청으로 관련 정보를 동적으로 받아온다.
    - 캐시는 GET방식에서 동작함
    - 캐시 주기로 0TTL을 사용하려면 If_Modified-Since 요청 지원

### POST 응답 캐시

-   매개 변숫값에 항상 같은 응답이 오는 경우
-   개인 정보가 포함되지 않은 경우
-   요청 사이즈가 크지 않은 경우

#

## 고급 캐시 전략

### Edge Side Include

    웹 페이지 조각을 동적으로 조합, 조립, 전달할 수 있도록 문법과 용도를 정의한 XML 기반 표준 마크업 언어

-   캐시가 지원해야 사용 가능
-   사용하는 경우
    1. 페이지 내 일부 종적인 부분 처리
        - 첫 HTML 다운로드 시점에 캐시 서버에서 실행되어 Ajax에 비해 한 번의 RTT를 절약할 수 있다.
        - 주기적으로 호출할 수 없어서 주기적 업데이트에는 적합하지 않다.
    2. 서로 다른 성격의 컨텐츠를 각각의 캐시 정책을 사용해 캐시할 때
    3. 사용자 등급에 따라 컨텐츠를 제한하고자 할 때
    4. 웹 애플리케이션 개발에 협업이 필요할 때

### HTML5 로컬 스토리지

-   기존의 쿠키보다 더 많은 데이터를 안전하게 저장할 수 있다.
-   프로토콜을 포함한 도메인별로 저장되며 같은 도메인 내에서 모든 리소스에 접속할 수 있다.
-   원할 때 필요한 데이터만 조회 가능하다.
-   CSS, JS등 저장해놓으면 로딩 속도를 대폭 개선할 수 있다.
